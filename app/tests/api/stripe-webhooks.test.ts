/**
 * Integration tests for Stripe webhook endpoint
 * Issue #332 - Stripe webhook handlers for subscription lifecycle
 *
 * Tests the POST /webhooks/stripe endpoint with real Express server and Stripe Test Mode.
 * Uses real Supabase Local for consistency with antimocking philosophy.
 * Creates real Stripe resources and verifies webhooks are delivered via Stripe CLI.
 *
 * IMPORTANT: These tests verify actual webhook delivery through Stripe CLI:
 * 1. Stripe API operations are performed (create, update, cancel)
 * 2. Stripe sends webhooks to CLI listener (configured in test setup)
 * 3. CLI forwards webhooks to local server with signature
 * 4. Server validates signature and processes webhooks
 * 5. Tests verify database updates from webhook handlers
 */

import { describe, expect, test, beforeAll, afterAll } from "bun:test";
import { createExpressApp } from "../../src/api/routes";
import { getServiceClient } from "../../src/db/client";
import { getStripeClient } from "../../src/api/stripe";
import { waitForCondition } from "../helpers/async-assertions";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { Server } from "node:http";
import type Stripe from "stripe";

/**
 * Helper: Create test user in database
 */
async function createTestUser(supabase: SupabaseClient, email: string): Promise<string> {
	const { data, error } = await supabase.auth.admin.createUser({
		email,
		email_confirm: true,
	});

	if (error || !data.user) {
		throw new Error(`Failed to create test user: ${error?.message}`);
	}

	return data.user.id;
}

/**
 * Helper: Create test API key for user
 */
async function createTestApiKey(supabase: SupabaseClient, userId: string): Promise<string> {
	const keyId = `test_key_${Date.now()}_${Math.random().toString(36).substring(7)}`;
	const { data, error } = await supabase
		.from("api_keys")
		.insert({
			user_id: userId,
			key_id: keyId,
			secret_hash: "test_secret_hash",
			tier: "free",
		})
		.select("id")
		.single();

	if (error || !data) {
		throw new Error(`Failed to create test API key: ${error?.message}`);
	}

	return data.id;
}

describe("POST /webhooks/stripe - Integration", () => {
	let supabase: SupabaseClient;
	let stripe: Stripe;
	let server: Server;
	let baseUrl: string;

	// Test user and real Stripe resources
	let testUserId: string;
	let testCustomer: Stripe.Customer;
	let testSubscription: Stripe.Subscription;

	beforeAll(async () => {
		// Check if Stripe credentials are configured
		if (!process.env.STRIPE_SECRET_KEY) {
			process.stdout.write(
				"[SKIP] Stripe webhook tests require STRIPE_SECRET_KEY environment variable. Set up Stripe test credentials to enable these tests.\n",
			);
			process.exit(0);
		}

		if (!process.env.STRIPE_WEBHOOK_SECRET) {
			process.stdout.write(
				"[SKIP] Stripe webhook tests require STRIPE_WEBHOOK_SECRET (auto-generated by Stripe CLI). Run 'bun test:setup' to start Stripe CLI listener.\n",
			);
			process.exit(0);
		}

		if (!process.env.STRIPE_SOLO_PRICE_ID) {
			process.stdout.write(
				"[SKIP] Stripe webhook tests require STRIPE_SOLO_PRICE_ID environment variable. Configure a test price in Stripe dashboard.\n",
			);
			process.exit(0);
		}

		// Initialize Supabase client (real connection for consistency)
		supabase = getServiceClient();

		// Initialize Stripe client (real Test Mode connection)
		stripe = getStripeClient();

		// Create test user
		const testEmail = `test-stripe-webhook-${Date.now()}@test.local`;
		testUserId = await createTestUser(supabase, testEmail);
		await createTestApiKey(supabase, testUserId);

		// Create real Stripe customer
		testCustomer = await stripe.customers.create({
			email: testEmail,
			metadata: {
				user_id: testUserId,
			},
		});

		// Create real Stripe subscription
		// NOTE: This triggers customer.subscription.created webhook automatically
		testSubscription = await stripe.subscriptions.create({
			customer: testCustomer.id,
			items: [{ price: process.env.STRIPE_SOLO_PRICE_ID }],
			metadata: {
				user_id: testUserId,
			},
		});

		// Create Express app
		const app = createExpressApp(supabase);

		// Start HTTP server on random port
		await new Promise<void>((resolve) => {
			server = app.listen(0, () => {
				const address = server.address();
				const port = typeof address === "object" ? address?.port : 0;
				baseUrl = `http://localhost:${port}`;
				resolve();
			});
		});
	});

	afterAll(async () => {
		// Clean up Stripe resources
		try {
			if (testSubscription?.id) {
				await stripe.subscriptions.cancel(testSubscription.id);
			}
			if (testCustomer?.id) {
				await stripe.customers.del(testCustomer.id);
			}
		} catch (error) {
			// Ignore cleanup errors
		}

		// Clean up database resources
		try {
			await supabase.from("subscriptions").delete().eq("user_id", testUserId);
			await supabase.from("api_keys").delete().eq("user_id", testUserId);
			await supabase.auth.admin.deleteUser(testUserId);
		} catch (error) {
			// Ignore cleanup errors
		}

		// Stop server
		await new Promise<void>((resolve) => {
			server?.close(() => resolve());
		});
	});

	test("handles customer.subscription.created webhook via Stripe CLI", async () => {
		/**
		 * WEBHOOK FLOW:
		 * 1. Subscription was created in beforeAll (real Stripe API call)
		 * 2. Stripe sent customer.subscription.created webhook to CLI
		 * 3. CLI forwarded to local server with valid signature
		 * 4. Server validated signature and invoked webhook handler
		 * 5. Handler created subscription record in database
		 * 6. We verify the database was updated correctly
		 */

		// Wait for webhook to be delivered and processed
		await waitForCondition(
			async () => {
				const { data } = await supabase
					.from("subscriptions")
					.select("*")
					.eq("user_id", testUserId)
					.eq("stripe_subscription_id", testSubscription.id)
					.single();
				return data !== null;
			},
			{
				timeout: 10000,
				interval: 200,
				message: "customer.subscription.created webhook was not processed - subscription not in database",
			},
		);

		// Verify webhook handler correctly stored subscription data
		const { data: subscription } = await supabase
			.from("subscriptions")
			.select("*")
			.eq("user_id", testUserId)
			.eq("stripe_subscription_id", testSubscription.id)
			.single();

		expect(subscription).not.toBeNull();
		expect(subscription?.stripe_customer_id).toBe(testCustomer.id);
		expect(subscription?.status).toBe(testSubscription.status);
		expect(subscription?.stripe_price_id).toBe(process.env.STRIPE_SOLO_PRICE_ID);
	});

	test("handles customer.subscription.updated webhook via Stripe CLI", async () => {
		/**
		 * WEBHOOK FLOW:
		 * 1. Update subscription via Stripe API (cancel at period end)
		 * 2. Stripe sends customer.subscription.updated webhook to CLI
		 * 3. CLI forwards to local server with valid signature
		 * 4. Server validates signature and invokes webhook handler
		 * 5. Handler updates subscription record in database
		 * 6. We verify the database reflects the update
		 */

		// Update subscription to cancel at period end
		await stripe.subscriptions.update(testSubscription.id, {
			cancel_at_period_end: true,
		});

		// Wait for webhook to be delivered and processed
		await waitForCondition(
			async () => {
				const { data } = await supabase
					.from("subscriptions")
					.select("cancel_at_period_end")
					.eq("stripe_subscription_id", testSubscription.id)
					.single();
				return data?.cancel_at_period_end === true;
			},
			{
				timeout: 10000,
				interval: 200,
				message: "customer.subscription.updated webhook was not processed - database not updated",
			},
		);

		// Verify webhook handler correctly updated subscription
		const { data: subscription } = await supabase
			.from("subscriptions")
			.select("*")
			.eq("stripe_subscription_id", testSubscription.id)
			.single();

		expect(subscription?.cancel_at_period_end).toBe(true);
	});

	test("handles customer.subscription.deleted webhook via Stripe CLI", async () => {
		/**
		 * WEBHOOK FLOW:
		 * 1. Cancel subscription immediately via Stripe API
		 * 2. Stripe sends customer.subscription.deleted webhook to CLI
		 * 3. CLI forwards to local server with valid signature
		 * 4. Server validates signature and invokes webhook handler
		 * 5. Handler marks subscription as canceled in database
		 * 6. We verify the status was updated
		 */

		// Cancel subscription immediately
		await stripe.subscriptions.cancel(testSubscription.id);

		// Wait for webhook to be delivered and processed
		await waitForCondition(
			async () => {
				const { data } = await supabase
					.from("subscriptions")
					.select("status")
					.eq("stripe_subscription_id", testSubscription.id)
					.single();
				return data?.status === "canceled";
			},
			{
				timeout: 10000,
				interval: 200,
				message: "customer.subscription.deleted webhook was not processed - status not updated",
			},
		);

		// Verify webhook handler correctly marked subscription as canceled
		const { data: subscription } = await supabase
			.from("subscriptions")
			.select("*")
			.eq("stripe_subscription_id", testSubscription.id)
			.single();

		expect(subscription?.status).toBe("canceled");
	});

	test("handles invoice.paid webhook via Stripe CLI", async () => {
		/**
		 * WEBHOOK FLOW:
		 * 1. Create new subscription via Stripe API
		 * 2. Stripe generates invoice and sends invoice.paid webhook to CLI
		 * 3. CLI forwards to local server with valid signature
		 * 4. Server validates signature and invokes webhook handler
		 * 5. Handler creates/updates subscription in database
		 * 6. We verify the subscription was created
		 */

		// Create new customer and subscription (triggers invoice.paid)
		const newCustomer = await stripe.customers.create({
			email: `test-invoice-${Date.now()}@test.local`,
			metadata: { user_id: testUserId },
		});

		const newSubscription = await stripe.subscriptions.create({
			customer: newCustomer.id,
			items: [{ price: process.env.STRIPE_SOLO_PRICE_ID! }],
			metadata: { user_id: testUserId },
		});

		// Wait for webhook to be delivered and processed
		await waitForCondition(
			async () => {
				const { data } = await supabase
					.from("subscriptions")
					.select("*")
					.eq("stripe_subscription_id", newSubscription.id)
					.single();
				return data !== null;
			},
			{
				timeout: 10000,
				interval: 200,
				message: "invoice.paid webhook was not processed - subscription not created",
			},
		);

		// Verify webhook handler created subscription
		const { data: subscription } = await supabase
			.from("subscriptions")
			.select("*")
			.eq("stripe_subscription_id", newSubscription.id)
			.single();

		expect(subscription).not.toBeNull();
		expect(subscription?.stripe_customer_id).toBe(newCustomer.id);

		// Cleanup
		await stripe.subscriptions.cancel(newSubscription.id);
		await stripe.customers.del(newCustomer.id);
	});

	test("processes webhooks idempotently (no duplicate records)", async () => {
		/**
		 * IDEMPOTENCY TEST:
		 * Verify that if Stripe sends duplicate webhook events (retry, etc),
		 * the handler processes them idempotently without creating duplicates.
		 *
		 * We trigger multiple rapid updates which may result in multiple webhooks,
		 * but should maintain single subscription record per stripe_subscription_id.
		 */

		// Get current subscription count for this user
		const { count: beforeCount } = await supabase
			.from("subscriptions")
			.select("*", { count: "exact", head: true })
			.eq("user_id", testUserId);

		// Trigger multiple rapid updates (may generate multiple webhooks)
		await Promise.all([
			stripe.subscriptions.update(testSubscription.id, {
				metadata: { idempotency_test: "1" },
			}),
			stripe.subscriptions.update(testSubscription.id, {
				metadata: { idempotency_test: "2" },
			}),
		]);

		// Wait for all webhooks to be processed
		await new Promise((resolve) => setTimeout(resolve, 3000));

		// Verify subscription count hasn't increased (no duplicates)
		const { count: afterCount } = await supabase
			.from("subscriptions")
			.select("*", { count: "exact", head: true })
			.eq("user_id", testUserId);

		expect(afterCount).toBe(beforeCount);

		// Verify subscription still exists with expected ID
		const { data: subscription } = await supabase
			.from("subscriptions")
			.select("*")
			.eq("stripe_subscription_id", testSubscription.id)
			.single();

		expect(subscription).not.toBeNull();
	});
});
