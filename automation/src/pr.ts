/**
 * PR creation module for automated workflow completion
 * Commits changes, pushes branch, and creates PR via gh CLI
 */

export interface PRCreationOptions {
  worktreePath: string;
  branchName: string;
  issueNumber: number;
  filesModified: string[];
  dryRun: boolean;
  metrics?: {
    inputTokens: number;
    outputTokens: number;
    totalCostUsd: number;
    durationMs: number;
  };
}

export interface PRCreationResult {
  success: boolean;
  prUrl: string | null;
  commitSha: string | null;
  errorMessage: string | null;
}

/**
 * Execute a git/gh command and return result
 */
async function execCommand(
  args: string[],
  cwd: string
): Promise<{ stdout: string; stderr: string; exitCode: number }> {
  const proc = Bun.spawn(args, {
    cwd,
    stdout: "pipe",
    stderr: "pipe",
  });

  const [stdout, stderr, exitCode] = await Promise.all([
    new Response(proc.stdout).text(),
    new Response(proc.stderr).text(),
    proc.exited,
  ]);

  return { stdout: stdout.trim(), stderr: stderr.trim(), exitCode };
}

/**
 * Format duration in human-readable form
 */
function formatDuration(ms: number): string {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = seconds % 60;

  if (minutes > 0) {
    return `${minutes}m ${remainingSeconds}s`;
  }
  return `${seconds}s`;
}

/**
 * Stage and commit all modified files
 * @returns Commit SHA on success, null on failure
 */
export async function commitChanges(
  worktreePath: string,
  issueNumber: number,
  filesModified: string[]
): Promise<string | null> {
  try {
    // Stage all modified files
    if (filesModified.length > 0) {
      const { exitCode: addExitCode, stderr: addStderr } = await execCommand(
        ["git", "add", ...filesModified],
        worktreePath
      );
      if (addExitCode !== 0) {
        process.stderr.write(`Failed to stage files: ${addStderr}\n`);
        // Fallback to staging all changes
        const { exitCode: addAllExitCode, stderr: addAllStderr } = await execCommand(
          ["git", "add", "-A"],
          worktreePath
        );
        if (addAllExitCode !== 0) {
          process.stderr.write(`Failed to stage all changes: ${addAllStderr}\n`);
          return null;
        }
      }
    } else {
      // No specific files, stage all changes
      const { exitCode, stderr } = await execCommand(
        ["git", "add", "-A"],
        worktreePath
      );
      if (exitCode !== 0) {
        process.stderr.write(`Failed to stage changes: ${stderr}\n`);
        return null;
      }
    }

    // Create commit
    const commitMessage = `fix(automation): implement issue #${issueNumber}

Auto-generated by KotaDB automation workflow.`;

    const { exitCode: commitExitCode, stderr: commitStderr } = await execCommand(
      ["git", "commit", "-m", commitMessage],
      worktreePath
    );

    if (commitExitCode !== 0) {
      process.stderr.write(`Failed to create commit: ${commitStderr}\n`);
      return null;
    }

    // Get commit SHA
    const { stdout: sha, exitCode: shaExitCode } = await execCommand(
      ["git", "rev-parse", "HEAD"],
      worktreePath
    );

    if (shaExitCode !== 0) {
      process.stderr.write(`Failed to get commit SHA\n`);
      return null;
    }

    process.stdout.write(`Created commit ${sha.substring(0, 7)} for #${issueNumber}\n`);
    return sha;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    process.stderr.write(`Commit failed: ${errorMessage}\n`);
    return null;
  }
}

/**
 * Push branch to origin
 * @returns true on success, false on failure
 */
export async function pushBranch(
  worktreePath: string,
  branchName: string
): Promise<boolean> {
  try {
    process.stdout.write(`Pushing branch ${branchName} to origin...\n`);

    const { exitCode, stderr } = await execCommand(
      ["git", "push", "-u", "origin", branchName],
      worktreePath
    );

    if (exitCode !== 0) {
      process.stderr.write(`Failed to push branch: ${stderr}\n`);
      return false;
    }

    process.stdout.write(`Branch ${branchName} pushed to origin\n`);
    return true;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    process.stderr.write(`Push failed: ${errorMessage}\n`);
    return false;
  }
}

/**
 * Build PR body with metrics summary
 */
function buildPRBody(
  issueNumber: number,
  metrics?: PRCreationOptions["metrics"]
): string {
  let body = `<!-- KOTADB-AUTOMATION-BOT -->
## Summary
Auto-generated PR for issue #${issueNumber}

`;

  if (metrics) {
    body += `## Metrics
| Metric | Value |
|--------|-------|
| Input Tokens | ${metrics.inputTokens.toLocaleString()} |
| Output Tokens | ${metrics.outputTokens.toLocaleString()} |
| Cost | $${metrics.totalCostUsd.toFixed(4)} |
| Duration | ${formatDuration(metrics.durationMs)} |

`;
  }

  body += `Fixes #${issueNumber}

---
*Generated by KotaDB Automation*`;

  return body;
}

/**
 * Create PR via gh CLI
 * @returns PR URL on success, null on failure
 */
export async function createPullRequest(
  issueNumber: number,
  branchName: string,
  metrics?: PRCreationOptions["metrics"]
): Promise<string | null> {
  try {
    process.stdout.write(`Creating PR for #${issueNumber}...\n`);

    const title = `fix(automation): #${issueNumber}`;
    const body = buildPRBody(issueNumber, metrics);

    const { stdout, stderr, exitCode } = await execCommand(
      [
        "gh",
        "pr",
        "create",
        "--base",
        "develop",
        "--head",
        branchName,
        "--title",
        title,
        "--body",
        body,
      ],
      process.cwd()
    );

    if (exitCode !== 0) {
      process.stderr.write(`Failed to create PR: ${stderr}\n`);
      return null;
    }

    // gh pr create outputs the PR URL on success
    const prUrl = stdout;
    process.stdout.write(`PR created: ${prUrl}\n`);
    return prUrl;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    process.stderr.write(`PR creation failed: ${errorMessage}\n`);
    return null;
  }
}

/**
 * Main orchestrator-facing function for PR creation
 * Handles the full workflow: commit, push, create PR
 */
export async function handlePRCreation(
  options: PRCreationOptions
): Promise<PRCreationResult> {
  const { worktreePath, branchName, issueNumber, filesModified, dryRun, metrics } = options;

  // Handle dry-run mode
  if (dryRun) {
    process.stdout.write(`[dry-run] Would commit changes for #${issueNumber}\n`);
    process.stdout.write(`[dry-run] Would push branch ${branchName} to origin\n`);
    process.stdout.write(`[dry-run] Would create PR targeting develop branch\n`);
    return {
      success: true,
      prUrl: null,
      commitSha: null,
      errorMessage: null,
    };
  }

  // Step 1: Commit changes
  const commitSha = await commitChanges(worktreePath, issueNumber, filesModified);
  if (!commitSha) {
    return {
      success: false,
      prUrl: null,
      commitSha: null,
      errorMessage: "Failed to commit changes",
    };
  }

  // Step 2: Push branch
  const pushSuccess = await pushBranch(worktreePath, branchName);
  if (!pushSuccess) {
    return {
      success: false,
      prUrl: null,
      commitSha,
      errorMessage: "Failed to push branch to origin",
    };
  }

  // Step 3: Create PR
  const prUrl = await createPullRequest(issueNumber, branchName, metrics);
  if (!prUrl) {
    return {
      success: false,
      prUrl: null,
      commitSha,
      errorMessage: "Failed to create pull request",
    };
  }

  return {
    success: true,
    prUrl,
    commitSha,
    errorMessage: null,
  };
}
