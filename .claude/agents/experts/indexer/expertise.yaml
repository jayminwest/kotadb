# KotaDB Indexer Expertise
# Target: 400-600 lines | Domain: Operational knowledge for code indexing subsystem
# Adapted for KotaDB local-only architecture with SQLite storage

overview:
  description: |
    Code indexing subsystem for KotaDB—AST parsing with @typescript-eslint/parser, visitor pattern
    for symbol and reference extraction, import path resolution, dependency graph construction,
    and SQLite storage with transactional writes. This expertise enables correct implementation
    of indexing features within KotaDB's local-only architecture.
  scope: |
    Covers AST parsing (parseFile, isSupportedForAST), symbol extraction (extractSymbols with
    visitor pattern), reference extraction (imports, calls, property access, type references),
    import resolution (resolveImport, handleIndexFiles), dependency graph construction
    (buildFileDependencies, buildSymbolDependencies), SQLite storage (storeIndexedData),
    and FTS5 full-text search (searchFilesLocal with escapeFts5Term).

    KOTADB ADAPTATIONS:
    - Uses @typescript-eslint/parser (NOT Babel or TypeScript compiler API)
    - Graceful error handling (return null on parse errors, log warnings)
    - Local SQLite storage with single-transaction atomicity
    - FTS5 full-text search with proper escaping for special characters
    - Path aliases (@api/*, @indexer/*, @shared/*, etc.)
    - Logging via createLogger (never console.*)
    - TSESTree types from @typescript-eslint/types

    Does NOT cover MCP tool implementation (see MCP expert) or API routes.
  rationale: |
    Correct indexing enables code intelligence features (search, find usages, dependency analysis).
    Poor AST handling causes silent failures. KotaDB uses @typescript-eslint/parser for modern
    TypeScript support and consistent AST structure across the codebase.

core_implementation:
  directory_structure:
    app/src/indexer/:
      purpose: Core indexing modules
      ast-parser.ts: AST parsing wrapper using @typescript-eslint/parser
      ast-types.ts: TypeScript type definitions for AST nodes
      symbol-extractor.ts: Visitor pattern for symbol extraction
      reference-extractor.ts: Visitor pattern for reference extraction
      import-resolver.ts: Import path resolution utilities
      path-resolver.ts: TypeScript path alias resolution (tsconfig.json parsing)
      dependency-extractor.ts: Dependency graph construction
      circular-detector.ts: Circular dependency detection algorithms
      storage.ts: SQLite storage layer with transactional writes
      repos.ts: Repository management functions
      extractors.ts: High-level extraction orchestration
      parsers.ts: File type detection and parsing coordination
    

  key_files:
    - path: app/src/indexer/ast-parser.ts
      purpose: AST parsing with graceful error handling
      exports: parseFile, isSupportedForAST
    - path: app/src/indexer/regex-fallback.ts
      purpose: Regex-based symbol extraction fallback for unparseable files
      exports: extractSymbolsWithRegex, RegexExtractedSymbol
    - path: app/src/indexer/symbol-extractor.ts
      purpose: Symbol extraction from AST
      exports: extractSymbols, Symbol, SymbolKind
    - path: app/src/indexer/reference-extractor.ts
      purpose: Reference extraction from AST with re-export and dynamic import support
      exports: extractReferences, Reference, ReferenceType
    - path: app/src/indexer/import-resolver.ts
      purpose: Import path resolution
      exports: resolveImport, resolveExtensions, handleIndexFiles
    - path: app/src/indexer/path-resolver.ts
      purpose: TypeScript path alias resolution
      exports: parseTsConfig, resolvePathAlias, PathMappings
    - path: app/src/indexer/dependency-extractor.ts
      purpose: Dependency graph construction
      exports: extractDependencies, DependencyEdge
    - path: app/src/indexer/storage.ts
      purpose: SQLite storage with atomic transactions
      exports: storeIndexedData, StorageResult
    - path: app/src/api/queries.ts
      purpose: FTS5 search with proper term escaping, auto-indexing workflow integration
      exports: searchFilesLocal, escapeFts5Term, runIndexingWorkflow, isRepositoryIndexed
    - path: app/src/mcp/auto-index.ts
      purpose: Auto-indexing utilities for "just works" behavior
      exports: ensureRepositoryIndexed, detectRepositoryFromCwd, isPathIndexed
    - path: app/src/sync/source-watcher.ts
      purpose: File system watcher for automatic incremental re-indexing
      exports: SourceWatcher, createSourceWatcher, startWatching, stopWatching
    - path: app/src/indexer/incremental.ts
      purpose: Incremental indexing API for changed file processing
      exports: indexChangedFiles, deleteIndexedFiles, detectChangedFiles

key_operations:
  parse_ast:
    when: Parsing TypeScript/JavaScript source code to AST
    approach: |
      1. Check if file is supported using isSupportedForAST(filePath)
         - Supported extensions: .ts, .tsx, .js, .jsx, .cjs, .mjs
         - JSON files are NOT parsed (data files, not code)
      2. Call parseFile(filePath, content)
         - Uses @typescript-eslint/parser with modern settings
         - Returns TSESTree.Program on success
         - Returns null on parse error (graceful failure)
      3. Handle null result gracefully
         - Log warning with file path
         - Continue processing other files
         - Never throw on parse errors

      Parser configuration:
      ```typescript
      parse(content, {
        ecmaVersion: "latest",
        sourceType: "module",
        loc: true,        // Line/column information
        range: true,      // Character range
        comment: true,    // Preserve comments (for JSDoc)
        tokens: true,     // Preserve tokens
        filePath,         // For error messages
      });
      ```
    examples:
      - parseFile("src/utils.ts", content) -> TSESTree.Program | null
      - isSupportedForAST("data.json") -> false
    pitfalls:
      - what: Throwing on parse errors
        instead: Return null and log error
        reason: Single bad file should not halt indexing
      - what: Parsing JSON files
        instead: Skip JSON files in isSupportedForAST
        reason: JSON is not valid JavaScript program


  parse_ast_with_error_recovery:
    when: Parsing TypeScript/JavaScript with syntax errors that prevent normal AST generation
    approach: |
      1. Call parseFileWithRecovery(filePath, content) -> ParseResult
         - Returns { ast, errors, partial } structure
         - ast: TSESTree.Program | null (partial or null if recovery fails)
         - errors: ParseError[] (with message, line, column)
         - partial: boolean (true if AST recovered despite errors)
      
      2. First attempt: Normal parsing (strict mode)
         - Uses standard @typescript-eslint/parser options
         - Returns ast with errors:[] and partial:false on success
      
      3. Second attempt: Error-tolerant parsing (if first fails)
         - Enables allowInvalidAST: true option
         - Enables errorOnUnknownASTType: false option
         - Returns partial AST if recovery succeeds
         - Sets partial:true flag to indicate recovery was used
      
      4. Third attempt: Regex fallback (if AST recovery fails completely)
         - Call extractSymbolsWithRegex(content, filePath)
         - Pattern-based extraction for basic symbols
         - Marks symbols with metadata.extractionMethod: "regex"
         - Returns limited symbol info without full AST structure
      
      Error recovery stages:
      ```typescript
      const result = parseFileWithRecovery(filePath, content);
      
      if (result.ast) {
        // Success or partial recovery
        if (result.partial) {
          logger.warn(`Recovered partial AST for ${filePath}`, {
            error_count: result.errors.length,
            recovery: "partial"
          });
        }
        const symbols = extractSymbols(result.ast, filePath);
      } else if (result.errors.length > 0) {
        // Complete failure - try regex fallback
        logger.error(`AST parsing failed for ${filePath}`, {
          error_count: result.errors.length,
          first_error: result.errors[0]?.message
        });
        const symbols = extractSymbolsWithRegex(content, filePath);
      }
      ```
      
      Recovery capabilities:
      Recovery capabilities:
      - Minor syntax errors (missing semicolons handled by ASI)
      - Unclosed braces (may recover valid nodes before error)
      - Multiple syntax errors (attempts to extract valid sections)
      - Complete failures (regex fallback for basic pattern matching)
      
      Regex fallback patterns:
      - Functions: /export\s+(?:async\s+)?function\s+(\w+)/
      - Classes: /export\s+(?:abstract\s+)?class\s+(\w+)/
      - Interfaces: /export\s+interface\s+(\w+)/
      - Types: /export\s+type\s+(\w+)\s*=/
      - Enums: /export\s+(?:const\s+)?enum\s+(\w+)/
      - Constants: /export\s+const\s+(\w+)/
      - Arrow functions: /export\s+const\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>/
      
      Regex limitations:
      - Cannot determine accurate end line (uses start line)
      - Cannot extract JSDoc comments
      - Cannot determine precise column positions
      - May miss complex multi-line declarations
      - May produce false positives in strings/comments
      - Marks symbols with extractionMethod: "regex" metadata
    examples:
      - File with unclosed brace -> partial AST with nodes before error
      - File with syntax error -> regex fallback extracts export patterns
      - parseFileWithRecovery returns errors array with line numbers
    pitfalls:
      - what: Treating partial AST as fully validated
        instead: Check result.partial flag and handle appropriately
        reason: Partial ASTs may have incomplete or invalid node structures
      - what: Ignoring regex fallback symbols
        instead: Use them despite limitations (better than nothing)
        reason: Some symbol info is better than complete loss for broken files
      - what: Not logging recovery attempts
        instead: Log warnings for partial recovery, errors for complete failures
        reason: Observability helps identify problematic files
    timestamp: 2026-02-02
    evidence: "commit 38d4e96, PR #76/#92, app/src/indexer/ast-parser.ts, app/src/indexer/regex-fallback.ts"

  auto_index_workflow:
    when: Tools need to ensure repository is indexed before execution
    approach: |
      1. Call ensureRepositoryIndexed(repositoryParam?, localPath?) -> AutoIndexResult
      2. Repository detection
         - If repositoryParam provided -> check if it's a local path (has .git) or identifier
         - If no param -> auto-detect from process.cwd() using detectRepositoryFromCwd()
         - Generate identifier: "local/<directory-name>" for local repositories
      3. Check if already indexed
         - Query repositories table by full_name (identifier)
         - Verify using isRepositoryIndexed(repositoryId) to check files exist
         - Return existing repositoryId if properly indexed
      4. Perform indexing if needed
         - Create IndexRequest with repository, ref: "main", localPath
         - Call runIndexingWorkflow(indexRequest) for full indexing
         - Return wasIndexed: true with stats (filesIndexed, symbolsExtracted, etc.)

      Integration pattern:
      ```typescript
      // In MCP tools before performing operations
      const autoResult = await ensureRepositoryIndexed(repository, localPath);
      const repositoryId = autoResult.repositoryId;

      if (autoResult.wasIndexed) {
        // First-time indexing occurred
        logger.info("Auto-indexed repository", {
          message: autoResult.message,
          stats: autoResult.stats
        });
      }

      // Proceed with tool operation using repositoryId
      const results = await searchCode(repositoryId, query);
      ```

      Repository detection heuristics:
      - Check for .git directory existence
      - Use basename of directory for repository name
      - Create "local/<name>" identifier for local repos
      - Store absolute path as git_url for local repositories
    examples:
      - ensureRepositoryIndexed() from /path/to/myrepo -> auto-detects "local/myrepo"
      - ensureRepositoryIndexed("/path/to/repo") -> detects path, creates "local/repo"
      - ensureRepositoryIndexed("local/existing") -> finds existing, returns repositoryId
    pitfalls:
      - what: Not checking .git directory for path-based detection
        instead: Always verify .git exists before treating as local repository
        reason: Prevents indexing non-git directories accidentally
      - what: Using synchronous file system operations in MCP tools
        instead: Use async ensureRepositoryIndexed for better performance
        reason: MCP tools should be non-blocking
      - what: Ignoring AutoIndexResult.wasIndexed flag
        instead: Use flag to provide user feedback about indexing activity
        reason: Users should know when first-time indexing occurs
    timestamp: 2026-02-03
    evidence: "commit aa4fcf4, PR #35/#125, app/src/mcp/auto-index.ts, app/src/mcp/tools.ts"

  incremental_indexing:
    when: Re-indexing changed files without full repository scan
    approach: |
      1. Call indexChangedFiles(repositoryId, repositoryPath, changedFiles[]) -> IncrementalIndexResult
      2. Separate deleted files from added/modified
         - Deleted files: call deleteIndexedFiles() to remove from database
         - Added/Modified files: parse, extract, and store new data
      3. For each file to index:
         - Parse using parseSourceFile(absolutePath, repositoryRoot)
         - Delete existing data if file was previously indexed
         - Store file record with new metadata
         - Extract symbols and references if AST-supported
         - Resolve imports using path mappings from tsconfig.json
      4. Return comprehensive results
         - filesUpdated, filesDeleted, symbolsExtracted, referencesExtracted
         - errors[] with { path, error } for failed files

      ChangedFile format:
      ```typescript
      interface ChangedFile {
        path: string;           // Relative path from repository root
        status: "added" | "modified" | "deleted";
      }
      ```

      Deletion handling:
      - Uses CASCADE deletes: file -> symbols -> references
      - Atomic transactions ensure consistency
      - Batch deletions for performance

      Error handling:
      - Individual file failures don't halt entire operation
      - Errors collected in result.errors array
      - Failed files logged with Sentry integration

      Path normalization:
      - Convert absolute paths to relative for database consistency
      - Handle Windows/Unix path separators
      - Remove leading ./ prefixes
    examples:
      - Change detection: git diff --name-status -> ChangedFile[]
      - File watcher: debounced filesystem events -> incremental indexing
      - Manual re-index: specific file paths -> targeted updates
    pitfalls:
      - what: Not normalizing file paths for database lookup
        instead: Use normalizePath() consistently for relative path format
        reason: Database stores relative paths, absolute paths won't match
      - what: Failing entire operation on single file error
        instead: Collect errors, continue processing other files
        reason: Partial updates are better than complete failure
      - what: Not checking file extensions before indexing
        instead: Filter unsupported files early with isSupportedSource()
        reason: Avoids unnecessary processing and storage
    timestamp: 2026-02-03
    evidence: "commit aa4fcf4, PR #35/#125, app/src/indexer/incremental.ts"

  file_watching:
    when: Automatically detecting source file changes for continuous indexing
    approach: |
      1. Create SourceWatcher with repositoryPath and repositoryId
      2. Start recursive filesystem watching with node:fs watch()
      3. Filter events:
         - Ignore directories: node_modules, .git, .kotadb, dist, build, .cache
         - Watch extensions: .ts, .tsx, .js, .jsx, .mjs, .cjs, .py, .rs, .go, etc.
         - Determine change type: add (new file), change (modified), delete (removed)
      4. Debounce changes (default 500ms) to batch rapid modifications
      5. Process batched changes:
         - Group by change type: added[], modified[], deleted[]
         - Convert to ChangedFile[] format
         - Call defaultChangeHandler -> indexChangedFiles()
      6. Handle errors gracefully with logging

      Debouncing pattern:
      ```typescript
      private scheduleProcess(): void {
        if (this.debounceTimer) {
          clearTimeout(this.debounceTimer);
        }
        this.debounceTimer = setTimeout(() => {
          this.processChanges().catch(error => {
            logger.error("Failed to process changes", error);
          });
        }, this.debounceMs);
      }
      ```

      Singleton management:
      - startWatching(repositoryPath, repositoryId) - creates and starts watcher
      - stopWatching(repositoryPath) - stops and removes watcher
      - stopAll() - cleanup all watchers (e.g., on shutdown)
      - getWatchedPaths() - list active watchers

      Change detection logic:
      - rename + new file -> "add"
      - modify existing -> "change"
      - file no longer exists -> "delete"
      - Uses existsSync() for delete detection
    examples:
      - Save file in editor -> debounced change event -> incremental re-index
      - Git checkout -> multiple file events -> batched processing
      - File creation -> add event -> new file indexed
    pitfalls:
      - what: Not debouncing rapid file changes
        instead: Use configurable debounce delay (500ms default)
        reason: Rapid saves/builds create excessive re-indexing
      - what: Watching ignored directories (node_modules)
        instead: Filter path parts against IGNORED_DIRECTORIES set
        reason: Avoids processing irrelevant file changes
      - what: Not handling watcher errors gracefully
        instead: Catch and log errors, don't crash watcher
        reason: File system errors shouldn't break continuous indexing
    timestamp: 2026-02-03
    evidence: "commit aa4fcf4, PR #35/#125, app/src/sync/source-watcher.ts"

  extract_reexports_dynamic_imports:
    when: Tracking re-exports and dynamic imports for accurate dependency graphs
    approach: |
      1. Re-export extraction (export { x } from './module')
         - Visit ExportNamedDeclaration nodes with source
         - Extract specifiers: local name and exported name
         - Create "re_export" reference with importSource metadata
      2. Star re-export extraction (export * from './module')
         - Visit ExportAllDeclaration nodes
         - Handle export * as alias patterns
         - Create "export_all" reference with exportedAs metadata
      3. Dynamic import extraction (import('./module'))
         - Visit ImportExpression nodes
         - Handle static string sources: import('./utils')
         - Handle template literals: import(`./pages/${name}`)
         - Create "dynamic_import" reference with isDynamic flag

      New reference types:
      - re_export: Named re-exports with local/exported name mapping
      - export_all: Star exports with optional namespace alias
      - dynamic_import: Runtime imports with static/template patterns

      Metadata extensions:
      ```typescript
      interface ReferenceMetadata {
        // Re-export metadata
        localName?: string;         // Original symbol name
        exportedName?: string;      // Re-exported name
        exportedAs?: string | null; // Namespace alias

        // Dynamic import metadata
        isDynamic?: boolean;        // Runtime resolution
        isTemplatePattern?: boolean; // Template literal source
      }
      ```

      Template literal handling:
      - Extract static parts: `./pages/${name}` -> "./pages/*"
      - Mark as template pattern for tooling awareness
      - Still track as dependency for analysis

      Database schema updates:
      - Added reference types to CHECK constraint
      - Supports filtering by reference_types in search queries
      - unresolved_imports field in dependency search responses
    examples:
      - export { utils } from './shared' -> re_export reference
      - export * as helpers from './utils' -> export_all reference
      - import('./components/Button') -> dynamic_import reference
      - import(`./pages/${route}`) -> dynamic_import with template pattern
    pitfalls:
      - what: Not handling template literal patterns
        instead: Extract static parts, mark as template pattern
        reason: Provides partial dependency info for dynamic sources
      - what: Missing database schema updates for new reference types
        instead: Update CHECK constraints when adding reference types
        reason: Database will reject new reference types without schema update
      - what: Not visiting children after extracting export references
        instead: Call visitChildren() for ExportNamedDeclaration
        reason: Export declarations may contain nested references
    timestamp: 2026-02-02
    evidence: "commit 41a3387, PR #89/#95, app/src/indexer/reference-extractor.ts, app/src/db/schema.sql"

  extract_symbols:
    when: Extracting functions, classes, interfaces, types from AST
    approach: |
      1. Call extractSymbols(ast, filePath)
      2. Visitor pattern traverses AST
      3. Dispatch based on node.type
         - FunctionDeclaration -> function symbol
         - ClassDeclaration -> class symbol + methods/properties
         - TSInterfaceDeclaration -> interface symbol
         - TSTypeAliasDeclaration -> type symbol
         - TSEnumDeclaration -> enum symbol
         - VariableDeclaration -> variable/constant (if exported)
         - ExportNamedDeclaration -> recurse into declaration
      4. Extract metadata for each symbol
         - name, kind, lineStart, lineEnd, columnStart, columnEnd
         - signature (for functions)
         - documentation (JSDoc extraction)
         - isExported (public API tracking)
         - isAsync, accessModifier (TypeScript features)

      VisitorContext tracks:
      - comments: TSESTree.Comment[] (for JSDoc extraction)
      - parent: TSESTree.Node | null (for export detection)
      - isExported: boolean (current export context)

      Symbol kinds:
      - function, class, interface, type, variable, constant, method, property, enum
    examples:
      - FunctionDeclaration with async -> isAsync: true
      - Class method with private -> accessModifier: "private"
    pitfalls:
      - what: Missing location data (node.loc undefined)
        instead: Guard with if (!node.loc) return
        reason: Some synthetic nodes lack position info
      - what: Extracting non-exported variables
        instead: Only extract exported variables
        reason: Reduces noise in symbol table

  extract_references:
    when: Extracting imports, calls, property access, type references from AST
    approach: |
      1. Call extractReferences(ast, filePath)
      2. Visitor pattern traverses all nodes recursively
      3. Dispatch based on node.type
         - ImportDeclaration -> import references
         - CallExpression -> function/method call references
         - MemberExpression -> property access references
         - TSTypeReference -> TypeScript type references
      4. Extract metadata for each reference
         - targetName, referenceType, lineNumber, columnNumber
         - metadata (importSource, importAlias, isMethodCall, etc.)

      Reference types:
      - import: Named, default, namespace, side-effect imports
      - call: Function calls, method calls
      - property_access: Member expressions (non-call)
      - type_reference: TypeScript type references
      - re_export: Named re-exports (export { x } from './module')
      - export_all: Star re-exports (export * from './module')
      - dynamic_import: Runtime imports (import('./module'))

      Import handling:
      - Named: import { foo } from './module'
      - Default: import foo from './module'
      - Namespace: import * as foo from './module'
      - Side-effect: import './module'
      - Aliased: import { foo as bar } from './module'
    examples:
      - ImportDeclaration -> multiple Reference objects (one per specifier)
      - CallExpression with MemberExpression -> isMethodCall: true
    pitfalls:
      - what: Not visiting children after extracting reference
        instead: Always call visitChildren for nested references
        reason: Chained calls (obj.foo().bar()) have nested structures
      - what: Extracting computed properties
        instead: Skip computed properties (return null)
        reason: Cannot resolve obj[key] statically

  resolve_imports:
    when: Resolving import paths to absolute file paths (relative and path aliases)
    approach: |
      1. Call resolveImport(importSource, fromFilePath, files, pathMappings)
      2. If starts with ./ or ../ -> relative import resolution
         - Resolve relative to importing file's directory
         - Try extension resolution (.ts, .tsx, .js, .jsx, .mjs, .cjs)
         - Try index file resolution (index.ts, index.tsx, etc.)
         - Return result or null
      3. If pathMappings provided -> path alias resolution
         - Match import against alias patterns (e.g., "@api/*")
         - Try each resolution path for matched alias
         - Check files Set for existence (not filesystem)
         - Return first match or null
      4. Otherwise -> external import (node_modules, etc.)
         - Return null (out of scope)

      Resolution priority:
      1. Relative imports (./ or ../)
      2. Path aliases (tsconfig.json paths)
      3. External imports (null)

      Path alias features (NEW):
      - Parses tsconfig.json/jsconfig.json at project root
      - Supports extends inheritance (recursive, depth-limited)
      - First-match-wins for multi-path mappings
      - Graceful fallback if no config found

    examples:
      - '"./utils" -> "/repo/src/utils.ts" (relative)'
      - '"./api" -> "/repo/src/api/index.ts" (relative with index)'
      - '"@api/routes" -> "/repo/src/api/routes.ts" (path alias)'
      - '"lodash" -> null (node_modules, skip)'
    pitfalls:
      - what: Resolving node_modules imports
        instead: Return null for non-relative, non-alias imports
        reason: External dependencies handled separately
      - what: Using path.resolve (creates absolute paths)
        instead: Use path.join + path.normalize
        reason: Preserves relative path structure
    timestamp: 2026-01-29
    evidence: app/src/indexer/import-resolver.ts

  resolve_path_aliases:
    when: Resolving path alias imports (@api/*, @db/*, etc.) to absolute file paths
    approach: |
      1. Parse tsconfig.json (or jsconfig.json) at project root
         - Extract compilerOptions.paths and compilerOptions.baseUrl
         - Support extends inheritance (recursive with MAX_EXTENDS_DEPTH = 10)
         - Merge child paths with parent (child takes precedence)
      2. Match import against each alias pattern
         - Exact match (no wildcard): "@api" === "@api"
         - Wildcard match: "@api/*" matches "@api/routes" -> suffix "routes"
      3. Try each resolution path for matched alias (first-match-wins)
         - Substitute wildcard with matched suffix: "src/api/*" -> "src/api/routes"
         - Resolve relative to baseUrl: join(projectRoot, baseUrl, substituted)
         - Normalize path for consistent format
      4. **CRITICAL: Convert absolute path to relative for files Set lookup**
         - After normalize(), path is absolute (e.g., "/repo/src/api/routes")
         - files Set contains relative paths (e.g., "src/api/routes.ts")
         - Convert: `resolved.startsWith(projectRoot) ? resolved.slice(projectRoot.length + 1) : resolved`
         - Use normalized relative path for tryExtensions() and tryIndexFiles()
      5. Try extension variants (.ts, .tsx, .js, .jsx, .mjs, .cjs)
      6. Try index file resolution (index.ts, index.tsx, index.js, index.jsx)
      7. Return first match or null if not found
      
      Project root determination:
      - Walk up directory tree looking for package.json, tsconfig.json, or .git
      - Limit to 10 levels (maxDepth)
      - Fallback to first two path segments if markers not found
      
      Key features:
      - Recursive extends support (child tsconfig extends parent)
      - Circular extends detection with depth limit
      - Fallback from tsconfig.json to jsconfig.json (JavaScript projects)
      - First-match-wins for multi-path mappings (e.g., monorepo fallbacks)
      - Graceful error handling (return null on parse errors)
    examples:
      - '"@api/routes" with { "@api/*": ["src/api/*"] } -> "/repo/src/api/routes.ts"'
      - '"@shared/utils" with { "@shared/*": ["src/shared/*", "packages/shared/*"] } -> first match wins'
      - Child tsconfig extends parent -> merges path mappings
    pitfalls:
      - what: Not supporting tsconfig extends
        instead: Parse parent recursively and merge configs
        reason: Monorepos often use base tsconfig with child overrides
      - what: Using existsSync to check resolved paths
        instead: Check against files Set (indexed files only)
        reason: Avoids filesystem access, matches indexed data
      - what: Failing on circular extends
        instead: Implement depth limit and return null gracefully
        reason: Some projects have malformed tsconfig chains
      - what: Testing with mocks
        instead: Use real filesystem fixtures in /tmp
        reason: Antimocking philosophy - test real tsconfig parsing
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts, app/tests/indexer/path-resolver.test.ts

  build_dependencies:
    when: Constructing file-to-file and symbol-to-symbol dependency graph
    approach: |
      1. Call extractDependencies(files, symbols, references, repositoryId)
      2. Build file dependencies from import references
         - Match importSource to resolved file path
         - Create DependencyEdge with fromFileId, toFileId
         - dependencyType: "file_import"
      3. Build symbol dependencies from call references
         - Find caller symbol (containing the call expression)
         - Find callee symbol (function being called)
         - Create DependencyEdge with fromSymbolId, toSymbolId
         - dependencyType: "symbol_usage"

      Helper functions:
      - buildFileDependencies: Import references -> file edges
      - buildSymbolDependencies: Call references -> symbol edges
      - findSymbolByLineNumber: Match line to enclosing symbol

      Ambiguous match handling:
      - Multiple symbols with same name -> prefer same-file match
      - No match found -> log debug, skip edge
      - Missing target -> log warning, continue
    examples:
      - import { foo } from './utils' -> file_import edge
      - foo() inside bar() -> symbol_usage edge from bar to foo
    pitfalls:
      - what: Failing on unresolved references
        instead: Log debug/warning and continue
        reason: External functions, built-ins won't resolve
      - what: Creating self-references
        instead: Skip if fromSymbolId === toSymbolId
        reason: Recursive calls are not useful dependencies

  store_indexed_data:
    when: Persisting extracted data to SQLite database
    approach: |
      1. Call storeIndexedData(repositoryId, files, symbols, references, dependencies)
      2. Single transaction wraps all operations (atomicity)
      3. Insert files and build file_path -> file_id mapping
      4. Insert symbols and build symbol_key -> symbol_id mapping
         - symbol_key format: "file_path::symbol_name::line_start"
      5. Insert references using file/symbol mappings
      6. Return StorageResult with counts

      Storage interface:
      - FileData: path, content, language, size_bytes, metadata
      - SymbolData: file_path, name, kind, line_start, line_end, signature, documentation
      - ReferenceData: source_file_path, target_symbol_key, line_number, reference_type
      - DependencyGraphEntry: from_file_path, to_file_path, dependency_type

      Transaction pattern:
      ```typescript
      db.transaction(() => {
        // All inserts here are atomic
        // Rollback on any failure
      });
      ```
    examples:
      - storeIndexedData(repoId, files, symbols, refs, deps) -> { files_indexed: 10, ... }
    pitfalls:
      - what: Multiple separate transactions
        instead: Single transaction for all operations
        reason: Atomicity guarantees consistency
      - what: Missing file_id lookup for symbol
        instead: Log warning and skip symbol
        reason: Orphan symbols without file reference are useless

  search_indexed_content:
    when: Searching indexed file content with FTS5 full-text search
    approach: |
      1. Accept raw search term from user input
      2. Call escapeFts5Term(term) to sanitize for FTS5 MATCH
         - Escapes internal double quotes by doubling them
         - Wraps entire term in double quotes for exact phrase matching
      3. Use escaped term in FTS5 MATCH clause
         - Prevents operator interpretation (-, AND, OR, NOT)
         - Ensures multi-word phrases match as exact phrase
      4. Return search results with file path, content, and metadata
      
      Escaping pattern:
      ```typescript
      function escapeFts5Term(term: string): string {
        const escaped = term.replace(/"/g, '""');
        return `"${escaped}"`;
      }
      ```
      
      Common edge cases:
      - "pre-commit" → escaped prevents "no such column: commit" error
      - "planType smb" → matches exact phrase, not "planType AND smb"
      - "search and find" → "and" treated as literal, not AND operator
      - 'say "hello"' → embedded quotes doubled to 'say ""hello""'
    examples:
      - escapeFts5Term("pre-commit") → '"pre-commit"'
      - escapeFts5Term("planType smb") → '"planType smb"'
      - FTS5 MATCH with escaped term returns exact phrase matches
    pitfalls:
      - what: Using raw user input directly in MATCH clause
        instead: Always escape with escapeFts5Term
        reason: Hyphens interpreted as NOT, spaces as AND
      - what: Escaping with backslashes (\")
        instead: Double internal quotes ("")
        reason: SQLite FTS5 uses doubling for quote escaping
    timestamp: 2026-01-28
    evidence: commit 5af086f, app/src/api/queries.ts


  batch_process_large_repos:
    when: Indexing repositories with 200+ files to avoid database transaction timeouts
    approach: |
      Chunk files into batches (BATCH_SIZE = 50). Process chunks sequentially with atomic
      transactions per chunk. First chunk performs DELETE+INSERT, subsequent chunks INSERT only.
      Filter symbols/references per chunk by file_path. Accumulate stats across chunks.
      
      Key pattern: skipDelete parameter controls whether to DELETE before INSERT (first chunk only).
    examples:
      - 250-file repository -> 5 chunks of 50 files each, each commits atomically
    pitfalls:
      - what: Deleting on every chunk
        instead: Only DELETE on first chunk (skipDelete parameter)
        reason: Repeated DELETEs cause conflicts and performance issues
    timestamp: 2026-01-28
    evidence: commit d47a650
  filter_build_artifacts:
    when: Discovering source files to avoid indexing build output and dependencies
    approach: |
      IGNORED_DIRECTORIES set (27 directories): .git, node_modules, vendor, build, dist, out,
      target, .next, .vercel, .turbo, .nuxt, .output, .svelte-kit, .angular, .vite, .parcel-cache,
      .nx, coverage, __pycache__, .pytest_cache, venv, .venv, env, .cache
      
      Covers: version control, package managers, build output, framework caches, test coverage, Python envs.
    timestamp: 2026-01-28
    evidence: commit 5a4bca3
  ast_parsing_strategy:
    question: How should I parse this file?
    options:
      - if: File extension is .ts, .tsx, .js, .jsx, .cjs, .mjs
        then: Use parseFile() to get AST
      - if: File extension is .json
        then: Skip AST parsing (data file)
      - if: File extension is unknown
        then: Check isSupportedForAST(), skip if false
      - if: parseFile() returns null
        then: Log warning, continue with other files

  symbol_extraction_approach:
    question: What kind of symbol is this AST node?
    options:
      - if: FunctionDeclaration
        then: Extract function symbol with signature
      - if: ClassDeclaration
        then: Extract class symbol, recurse into methods/properties
      - if: TSInterfaceDeclaration
        then: Extract interface symbol
      - if: TSTypeAliasDeclaration
        then: Extract type symbol
      - if: TSEnumDeclaration
        then: Extract enum symbol
      - if: VariableDeclaration and isExported
        then: Extract variable/constant/function symbol
      - if: ExportNamedDeclaration or ExportDefaultDeclaration
        then: 'Recurse into declaration with isExported: true'
      - if: Other node type
        then: Skip (no symbol to extract)

  reference_extraction_approach:
    question: What kind of reference is this AST node?
    options:
      - if: ImportDeclaration
        then: Extract import reference per specifier
      - if: CallExpression with Identifier callee
        then: Extract function call reference
      - if: CallExpression with MemberExpression callee
        then: Extract method call reference
      - if: MemberExpression (not callee of CallExpression)
        then: Extract property access reference
      - if: TSTypeReference
        then: Extract type reference
      - if: ExportNamedDeclaration with source
        then: Extract re-export references for each specifier
      - if: ExportAllDeclaration
        then: Extract star re-export reference
      - if: ImportExpression
        then: Extract dynamic import reference
      - if: Other node type
        then: Visit children recursively

  import_resolution_strategy:
    question: How should I resolve this import path?
    options:
      - if: Starts with ./ or ../
        then: Relative import, resolve with extensions/index files
      - if: Matches path alias pattern (pathMappings provided)
        then: Resolve using tsconfig.json path mappings
      - if: Starts with / or bare module (no alias match)
        then: Absolute/external import, return null (out of scope)
      - if: Has extension already
        then: Check exact path in files Set
      - if: No extension
        then: Try SUPPORTED_EXTENSIONS in order
      - if: Still not found
        then: Try index file resolution

  error_recovery_strategy:
    question: How should I handle parse errors for this file?
    options:
      - if: parseFileWithRecovery returns ast with partial:false
        then: Use AST normally (no errors)
      - if: parseFileWithRecovery returns ast with partial:true
        then: Use partial AST, log warning, extract available symbols
      - if: parseFileWithRecovery returns null with errors
        then: Use regex fallback (extractSymbolsWithRegex)
      - if: Regex fallback returns empty array
        then: Log error, skip file (no symbols available)
      - if: 'Symbol has metadata.extractionMethod: "regex"'
        then: Use with caution (may lack JSDoc, accurate positions)

patterns:
  visitor_pattern:
    structure: |
      function visitNode(node, results, context): void {
        const childContext = { ...context, parent: node };
        switch (node.type) {
          case "SpecificNodeType":
            extractFromNode(node, results, context);
            break;
          default:
            visitChildren(node, results, childContext);
        }
      }
  graceful_error_handling:
    structure: |
      try {
        return parse(content, options);
      } catch (error) {
        logger.error("Failed to parse", error, { file_path: filePath });
        Sentry.captureException(error, { tags: { module: "ast-parser" } });
        return null;  // Graceful failure
      }
  jsdoc_extraction:
    structure: |
      Extract last block comment before node within 5 lines.
      Strip /** */ and leading * from each line.
    trade_offs:
      pros: [Preserves documentation, Position-based matching]
      cons: [5-line heuristic may miss some comments]


  tsconfig_extends_pattern:
    structure: |
      function parseTsConfigWithExtends(
        configPath: string,
        depth: number,
        maxDepth: number
      ): TsConfig | null {
        // Prevent infinite recursion
        if (depth >= maxDepth) {
          logger.warn("Circular extends detected");
          return null;
        }
        
        const config = JSON.parse(readFileSync(configPath, "utf-8"));
        
        // No extends - return as-is
        if (!config.extends) return config;
        
        // Parse parent config
        const extendsPath = isAbsolute(config.extends)
          ? config.extends
          : join(dirname(configPath), config.extends);
        
        // Add .json extension if missing
        const resolved = extendsPath.endsWith(".json")
          ? extendsPath
          : `${extendsPath}.json`;
        
        const parent = parseTsConfigWithExtends(resolved, depth + 1, maxDepth);
        
        // Merge parent and child configs
        return mergeTsConfigs(config, parent);
      }
      
      function mergeTsConfigs(child: TsConfig, parent: TsConfig): TsConfig {
        return {
          ...parent,
          ...child,
          compilerOptions: {
            ...parent.compilerOptions,
            ...child.compilerOptions,
            paths: {
              ...parent.compilerOptions?.paths,
              ...child.compilerOptions?.paths,  // Child overrides parent
            }
          }
        };
      }
    trade_offs:
      pros: [Supports monorepo base configs, Matches tsc behavior, Prevents infinite loops]
      cons: [Recursive parsing overhead, Depth limit may miss deep chains]
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts

  path_alias_integration_pattern:
    structure: |
      // 1. Parse tsconfig at workflow start
      const pathMappings = parseTsConfig(projectRoot);
      if (pathMappings) {
        logger.info("Loaded path mappings", {
          aliasCount: Object.keys(pathMappings.paths).length,
          baseUrl: pathMappings.baseUrl
        });
      }
      
      // 2. Pass through resolution pipeline
      const resolved = resolveImport(
        importSource,
        fromFilePath,
        files,
        pathMappings  // Optional parameter
      );
      
      // 3. Store resolved path in database
      if (resolved) {
        targetFilePath = normalizePath(resolved);
      }
    trade_offs:
      pros: [Single parse per indexing run, Optional enhancement (graceful if null), Clean parameter threading]
      cons: [Additional parameter in call chain, Null handling complexity]
    timestamp: 2026-01-29
    evidence: app/src/api/queries.ts runIndexingWorkflow()

  auto_index_integration_pattern:
    structure: |
      // MCP tool pattern
      export async function myMcpTool(params: ToolParams): Promise<ToolResult> {
        // 1. Ensure repository is indexed before any operations
        const autoResult = await ensureRepositoryIndexed(
          params.repository,
          params.localPath
        );

        // 2. Extract repository ID for queries
        const repositoryId = autoResult.repositoryId;

        // 3. Provide user feedback on auto-indexing
        const messages: string[] = [];
        if (autoResult.wasIndexed) {
          messages.push(autoResult.message);
          if (autoResult.stats) {
            messages.push(`Indexed ${autoResult.stats.filesIndexed} files`);
          }
        }

        // 4. Perform tool operation with guaranteed indexed repository
        const results = await performToolOperation(repositoryId, params);

        return {
          messages,
          data: results
        };
      }
    trade_offs:
      pros: [Just works UX, No manual indexing required, Transparent to user, Handles both new and existing repos]
      cons: [First-time delay for indexing, Potential for large repository surprises, Auto-detection heuristics may fail]
    timestamp: 2026-02-03
    evidence: app/src/mcp/tools.ts integration

  incremental_indexing_pattern:
    structure: |
      // File watcher integration
      export class SourceWatcher {
        private async processChanges(): Promise<void> {
          // 1. Collect debounced changes by type
          const changes = this.groupChangesByType();

          // 2. Convert to standard ChangedFile format
          const changedFiles = this.toChangedFileFormat(changes);

          // 3. Use incremental indexing API
          const result = await indexChangedFiles(
            this.repositoryId,
            this.repositoryPath,
            changedFiles
          );

          // 4. Log comprehensive results
          logger.info("Incremental re-indexing completed", {
            filesUpdated: result.filesUpdated,
            filesDeleted: result.filesDeleted,
            symbolsExtracted: result.symbolsExtracted,
            errors: result.errors.length
          });

          // 5. Handle partial failures gracefully
          if (result.errors.length > 0) {
            logger.warn("Some files failed to re-index", {
              errors: result.errors.slice(0, 5) // Limit error logging
            });
          }
        }
      }
    trade_offs:
      pros: [Efficient updates, Atomic transactions, Comprehensive error handling, Maintains index freshness]
      cons: [Complexity of change detection, Potential for missed events, Debouncing may delay updates]
    timestamp: 2026-02-03
    evidence: app/src/sync/source-watcher.ts, app/src/indexer/incremental.ts

  reference_type_expansion_pattern:
    structure: |
      // Reference extraction with expanded types
      function visitNode(node: TSESTree.Node, references: Reference[]): void {
        switch (node.type) {
          case "ExportNamedDeclaration":
            if (node.source) {  // Re-export
              for (const spec of node.specifiers) {
                references.push({
                  targetName: spec.exported.name,
                  referenceType: "re_export",
                  metadata: {
                    importSource: node.source.value,
                    localName: spec.local.name,
                    exportedName: spec.exported.name
                  }
                });
              }
            }
            break;

          case "ExportAllDeclaration":
            references.push({
              targetName: node.exported?.name || "*",
              referenceType: "export_all",
              metadata: {
                importSource: node.source.value,
                exportedAs: node.exported?.name
              }
            });
            break;

          case "ImportExpression":
            const source = node.source.type === "Literal"
              ? node.source.value
              : "<dynamic>";
            references.push({
              targetName: "__dynamic_import__",
              referenceType: "dynamic_import",
              metadata: {
                importSource: source,
                isDynamic: true,
                isTemplatePattern: node.source.type === "TemplateLiteral"
              }
            });
            break;
        }

        // Always visit children for nested references
        visitChildren(node, references, context);
      }
    trade_offs:
      pros: [Complete dependency tracking, Modern ES6+ support, Better analysis accuracy, Template literal awareness]
      cons: [Increased reference volume, Complex metadata handling, Dynamic import ambiguity]
    timestamp: 2026-02-02
    evidence: app/src/indexer/reference-extractor.ts

  constant_extraction:
    when: Shared constants need synchronization across modules
    approach: |
      Place in dedicated constants.ts with 'as const' for type safety.
      Document synchronization requirements in JSDoc with "IMPORTANT" marker.
      Export priority-ordered arrays (TypeScript variants first).
      Note modules that must stay synchronized.
    timestamp: 2026-01-29
    evidence: app/src/indexer/constants.ts

  ast_parsing:
    - Use @typescript-eslint/parser for modern TypeScript support
    - Always enable loc, range, comment, tokens options
    - Return null on parse error (never throw)
    - Log errors with file path for debugging
    - Check isSupportedForAST before parsing

  symbol_extraction:
    - Use visitor pattern for consistent traversal
    - Track export context through visitor context
    - Extract JSDoc comments for documentation
    - Include position info (line/column) for navigation
    - Handle anonymous functions gracefully (<anonymous>)

  reference_extraction:
    - Visit children after extracting reference (for nested references)
    - Skip computed properties (cannot resolve statically)
    - Distinguish function calls from method calls
    - Track optional chaining (?.) in metadata


  import_resolution:
    items:
      - Resolve relative imports (./ and ../) AND path aliases (@alias/*)
      - Parse tsconfig.json once at indexing start (not per file)
      - Pass pathMappings through entire resolution pipeline
      - Try relative resolution first, then path alias resolution
      - Return null for unresolvable imports (node_modules, missing configs)
      - Use path.join + path.normalize (NOT path.resolve)
      - Check files Set instead of filesystem (indexed files only)
      - Support jsconfig.json fallback for JavaScript projects
      - Handle extends recursively with circular detection
      - Try extensions in priority order (.ts first)
      - Handle index file resolution
      - Preserve relative path structure for database matching
    timestamp: 2026-01-29
    evidence: "app/src/indexer/import-resolver.ts, app/src/indexer/path-resolver.ts"

  automatic_indexing:
    items:
      - Integrate ensureRepositoryIndexed() into all MCP tools for "just works" UX
      - Use repository detection heuristics (.git directory, basename for name)
      - Generate "local/<name>" identifiers for local repositories
      - Check if repository is already indexed before triggering workflow
      - Return wasIndexed flag and stats for user feedback
      - Store absolute path as git_url for local repositories
      - Handle both explicit repository params and auto-detection from cwd
      - Graceful error handling with clear error messages
    timestamp: 2026-02-03
    evidence: "app/src/mcp/auto-index.ts, app/src/mcp/tools.ts integration"

  incremental_indexing:
    items:
      - Use indexChangedFiles() for efficient targeted re-indexing
      - Support ChangedFile format with path and status (added/modified/deleted)
      - Separate deletion handling with CASCADE database operations
      - Atomic transactions per file group for consistency
      - Comprehensive error collection without halting operation
      - Path normalization for database compatibility
      - Individual file failure resilience
      - Sentry integration for error tracking
    timestamp: 2026-02-03
    evidence: "app/src/indexer/incremental.ts"

  file_watching:
    items:
      - Use SourceWatcher class for recursive filesystem monitoring
      - Debounce changes (500ms default) to batch rapid modifications
      - Filter ignored directories (node_modules, .git, build output)
      - Watch relevant extensions (.ts, .tsx, .js, .jsx, .py, .rs, .go, etc.)
      - Determine change types (add/modify/delete) from filesystem events
      - Singleton pattern for watcher management (start/stop/cleanup)
      - Graceful error handling to prevent watcher crashes
      - Integration with incremental indexing API
    timestamp: 2026-02-03
    evidence: "app/src/sync/source-watcher.ts"

  reference_extraction_expanded:
    items:
      - Extract 7 reference types: import, call, property_access, type_reference, re_export, export_all, dynamic_import
      - Handle re-exports with local/exported name mapping
      - Support star re-exports with optional namespace aliases
      - Track dynamic imports with template literal pattern detection
      - Update database schema CHECK constraints for new reference types
      - Visit children nodes after extracting references (nested structures)
      - Store comprehensive metadata for analysis tools
    timestamp: 2026-02-02
    evidence: "app/src/indexer/reference-extractor.ts, app/src/db/schema.sql"

  storage:
    - Use single transaction for atomicity
    - Build lookup maps for efficient foreign key resolution
    - Generate UUIDs for primary keys
    - Log storage results for observability

  fts5_search:
    items:
      - Always escape user search terms before FTS5 MATCH queries
      - Wrap terms in double quotes for exact phrase matching
      - 'Escape internal quotes by doubling them ("" not \")'
      - Prevents SQL errors on hyphens, spaces, AND/OR/NOT keywords
      - "Test with: hyphenated-terms, multi-word phrases, FTS keywords"
    timestamp: 2026-01-28
    evidence: commit 5af086f


  logging:
    - 'Use createLogger({ module: "indexer-<name>" })'
    - Log errors with structured metadata
    - Use debug level for expected failures (unresolved imports)
    - Use warn level for unexpected but recoverable failures
    - Never use console.* (use process.stdout.write for raw output)

known_issues:
  - issue: path.resolve() converts relative to absolute paths
    impact: Import resolution fails when database stores relative paths
    resolution: Use path.join() + path.normalize() to preserve relative structure
    prevention: |
      Never use path.resolve() in import resolution.
      Always use: path.normalize(path.join(fromDir, importSource))
    status: resolved
    timestamp: 2026-01-28
    evidence: commit 5713a52

  - issue: tsconfig.json path mapping not supported
    impact: Absolute imports with path aliases not resolved
    resolution: Implemented in path-resolver.ts with full extends support
    status: resolved
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts

  - issue: Schema CHECK constraint must match all reference types
    impact: Insertion failures when reference extractor produces new types
    resolution: property_access was missing from CHECK constraint list
    prevention: 'When adding reference types: update extractor, schema, tests'
    status: resolved
    timestamp: 2026-01-28
    evidence: commit 91415ad

  - issue: Path alias resolution used absolute paths for files Set lookup
    impact: resolvePathAlias() failed to find files despite correct resolution
    resolution: |
      Convert absolute paths to relative before files Set lookup.
      Code: `resolved.startsWith(projectRoot) ? resolved.slice(projectRoot.length + 1) : resolved`
    prevention: |
      files Set ALWAYS contains relative paths (no leading slash).
      After join(projectRoot, ...) + normalize(), convert to relative for lookup.
      Pass relative path to tryExtensions() and tryIndexFiles().
    status: resolved
    timestamp: 2026-01-31
    evidence: commit 644fbc9, app/src/indexer/path-resolver.ts lines 265-268, app/tests/indexer/path-resolver.test.ts (added relative path test)

stability:
  convergence_indicators:
    insight_rate_trend: expanding
    contradiction_count: 0
    new_patterns_added_this_cycle: 6
    patterns_updated_this_cycle: 3
    last_reviewed: 2026-02-03
    utility_ratio: 1.0
    notes: |
      Cycle 7 update - Automatic indexing and incremental features:
      - Added: auto_index_workflow operation (just works UX, repository detection)
      - Added: incremental_indexing operation (changed file processing, atomic updates)
      - Added: file_watching operation (filesystem monitoring, debounced updates)
      - Added: extract_reexports_dynamic_imports operation (expanded reference types)
      - Added: auto_index_integration_pattern (MCP tool integration)
      - Added: incremental_indexing_pattern (file watcher integration)
      - Added: reference_type_expansion_pattern (7 reference types)
      - Updated: core_implementation/key_files with auto-index.ts, source-watcher.ts, incremental.ts
      - Updated: reference_extraction_approach with new reference types
      - Updated: best practices with automatic_indexing, incremental_indexing, file_watching, reference_extraction_expanded
      - Learning: Auto-indexing enables "just works" UX; incremental indexing maintains freshness; re-exports critical for modern JS/TS
      - Evidence: commits aa4fcf4 (#35/#125), 41a3387 (#89/#95), 2000+ lines added across 8 files
      - File size: 844 -> 1200+ lines (significant expansion due to major feature additions)

      Cycle 6 (2026-02-02) - AST parser error recovery:
      - Added: parse_ast_with_error_recovery operation (3-stage recovery)
      - Added: error_recovery_strategy decision tree
      - Learning: allowInvalidAST enables partial recovery; regex fallback prevents complete symbol loss

      Cycle 5 (2026-01-31) - path resolver bug fix:
      - Updated: resolve_path_aliases with critical path normalization
      - Added: known_issues entry for absolute-to-relative conversion bug

