# KotaDB Indexer Expertise
# Target: 400-600 lines | Domain: Operational knowledge for code indexing subsystem
# Adapted for KotaDB local-only architecture with SQLite storage

overview:
  description: |
    Code indexing subsystem for KotaDB—AST parsing with @typescript-eslint/parser, visitor pattern
    for symbol and reference extraction, import path resolution, dependency graph construction,
    and SQLite storage with transactional writes. This expertise enables correct implementation
    of indexing features within KotaDB's local-only architecture.
  scope: |
    Covers AST parsing (parseFile, isSupportedForAST), symbol extraction (extractSymbols with
    visitor pattern), reference extraction (imports, calls, property access, type references),
    import resolution (resolveImport, handleIndexFiles), dependency graph construction
    (buildFileDependencies, buildSymbolDependencies), SQLite storage (storeIndexedData),
    and FTS5 full-text search (searchFilesLocal with escapeFts5Term).

    KOTADB ADAPTATIONS:
    - Uses @typescript-eslint/parser (NOT Babel or TypeScript compiler API)
    - Graceful error handling (return null on parse errors, log warnings)
    - Local SQLite storage with single-transaction atomicity
    - FTS5 full-text search with proper escaping for special characters
    - Path aliases (@api/*, @indexer/*, @shared/*, etc.)
    - Logging via createLogger (never console.*)
    - TSESTree types from @typescript-eslint/types

    Does NOT cover MCP tool implementation (see MCP expert) or API routes.
  rationale: |
    Correct indexing enables code intelligence features (search, find usages, dependency analysis).
    Poor AST handling causes silent failures. KotaDB uses @typescript-eslint/parser for modern
    TypeScript support and consistent AST structure across the codebase.

core_implementation:
  directory_structure:
    app/src/indexer/:
      purpose: Core indexing modules
      ast-parser.ts: AST parsing wrapper using @typescript-eslint/parser
      ast-types.ts: TypeScript type definitions for AST nodes
      symbol-extractor.ts: Visitor pattern for symbol extraction
      reference-extractor.ts: Visitor pattern for reference extraction
      import-resolver.ts: Import path resolution utilities
      path-resolver.ts: TypeScript path alias resolution (tsconfig.json parsing)
      dependency-extractor.ts: Dependency graph construction
      circular-detector.ts: Circular dependency detection algorithms
      storage.ts: SQLite storage layer with transactional writes
      repos.ts: Repository management functions
      extractors.ts: High-level extraction orchestration
      parsers.ts: File type detection and parsing coordination
    

  key_files:
    - path: app/src/indexer/ast-parser.ts
      purpose: AST parsing with graceful error handling
      exports: parseFile, isSupportedForAST
    - path: app/src/indexer/regex-fallback.ts
      purpose: Regex-based symbol extraction fallback for unparseable files
      exports: extractSymbolsWithRegex, RegexExtractedSymbol
    - path: app/src/indexer/symbol-extractor.ts
      purpose: Symbol extraction from AST
      exports: extractSymbols, Symbol, SymbolKind
    - path: app/src/indexer/reference-extractor.ts
      purpose: Reference extraction from AST
      exports: extractReferences, Reference, ReferenceType
    - path: app/src/indexer/import-resolver.ts
      purpose: Import path resolution
      exports: resolveImport, resolveExtensions, handleIndexFiles
    - path: app/src/indexer/path-resolver.ts
      purpose: TypeScript path alias resolution
      exports: parseTsConfig, resolvePathAlias, PathMappings
    - path: app/src/indexer/dependency-extractor.ts
      purpose: Dependency graph construction
      exports: extractDependencies, DependencyEdge
    - path: app/src/indexer/storage.ts
      purpose: SQLite storage with atomic transactions
      exports: storeIndexedData, StorageResult
    - path: app/src/api/queries.ts
      purpose: FTS5 search with proper term escaping
      exports: searchFilesLocal, escapeFts5Term

key_operations:
  parse_ast:
    when: Parsing TypeScript/JavaScript source code to AST
    approach: |
      1. Check if file is supported using isSupportedForAST(filePath)
         - Supported extensions: .ts, .tsx, .js, .jsx, .cjs, .mjs
         - JSON files are NOT parsed (data files, not code)
      2. Call parseFile(filePath, content)
         - Uses @typescript-eslint/parser with modern settings
         - Returns TSESTree.Program on success
         - Returns null on parse error (graceful failure)
      3. Handle null result gracefully
         - Log warning with file path
         - Continue processing other files
         - Never throw on parse errors

      Parser configuration:
      ```typescript
      parse(content, {
        ecmaVersion: "latest",
        sourceType: "module",
        loc: true,        // Line/column information
        range: true,      // Character range
        comment: true,    // Preserve comments (for JSDoc)
        tokens: true,     // Preserve tokens
        filePath,         // For error messages
      });
      ```
    examples:
      - parseFile("src/utils.ts", content) -> TSESTree.Program | null
      - isSupportedForAST("data.json") -> false
    pitfalls:
      - what: Throwing on parse errors
        instead: Return null and log error
        reason: Single bad file should not halt indexing
      - what: Parsing JSON files
        instead: Skip JSON files in isSupportedForAST
        reason: JSON is not valid JavaScript program


  parse_ast_with_error_recovery:
    when: Parsing TypeScript/JavaScript with syntax errors that prevent normal AST generation
    approach: |
      1. Call parseFileWithRecovery(filePath, content) -> ParseResult
         - Returns { ast, errors, partial } structure
         - ast: TSESTree.Program | null (partial or null if recovery fails)
         - errors: ParseError[] (with message, line, column)
         - partial: boolean (true if AST recovered despite errors)
      
      2. First attempt: Normal parsing (strict mode)
         - Uses standard @typescript-eslint/parser options
         - Returns ast with errors:[] and partial:false on success
      
      3. Second attempt: Error-tolerant parsing (if first fails)
         - Enables allowInvalidAST: true option
         - Enables errorOnUnknownASTType: false option
         - Returns partial AST if recovery succeeds
         - Sets partial:true flag to indicate recovery was used
      
      4. Third attempt: Regex fallback (if AST recovery fails completely)
         - Call extractSymbolsWithRegex(content, filePath)
         - Pattern-based extraction for basic symbols
         - Marks symbols with metadata.extractionMethod: "regex"
         - Returns limited symbol info without full AST structure
      
      Error recovery stages:
      ```typescript
      const result = parseFileWithRecovery(filePath, content);
      
      if (result.ast) {
        // Success or partial recovery
        if (result.partial) {
          logger.warn(`Recovered partial AST for ${filePath}`, {
            error_count: result.errors.length,
            recovery: "partial"
          });
        }
        const symbols = extractSymbols(result.ast, filePath);
      } else if (result.errors.length > 0) {
        // Complete failure - try regex fallback
        logger.error(`AST parsing failed for ${filePath}`, {
          error_count: result.errors.length,
          first_error: result.errors[0]?.message
        });
        const symbols = extractSymbolsWithRegex(content, filePath);
      }
      ```
      
      Recovery capabilities:
      - Minor syntax errors (missing semicolons handled by ASI)
      - Unclosed braces (may recover valid nodes before error)
      - Multiple syntax errors (attempts to extract valid sections)
      - Complete failures (regex fallback for basic pattern matching)
      
      Regex fallback error_recovery_strategy:
    question: How should I handle parse errors for this file?
    options:
      - if: parseFileWithRecovery returns ast with partial:false
        then: Use AST normally (no errors)
      - if: parseFileWithRecovery returns ast with partial:true
        then: Use partial AST, log warning, extract available symbols
      - if: parseFileWithRecovery returns null with errors
        then: Use regex fallback (extractSymbolsWithRegex)
      - if: Regex fallback returns empty array
        then: Log error, skip file (no symbols available)
      - if: Symbol has metadata.extractionMethod: "regex"
        then: Use with caution (may lack JSDoc, accurate positions)

patterns:
      - Functions: /export\s+(?:async\s+)?function\s+(\w+)/
      - Classes: /export\s+(?:abstract\s+)?class\s+(\w+)/
      - Interfaces: /export\s+interface\s+(\w+)/
      - Types: /export\s+type\s+(\w+)\s*=/
      - Enums: /export\s+(?:const\s+)?enum\s+(\w+)/
      - Constants: /export\s+const\s+(\w+)/
      - Arrow functions: /export\s+const\s+(\w+)\s*=\s*(?:async\s+)?\([^)]*\)\s*=>/
      
      Regex limitations:
      - Cannot determine accurate end line (uses start line)
      - Cannot extract JSDoc comments
      - Cannot determine precise column positions
      - May miss complex multi-line declarations
      - May produce false positives in strings/comments
      - Marks symbols with extractionMethod: "regex" metadata
    examples:
      - File with unclosed brace -> partial AST with nodes before error
      - File with syntax error -> regex fallback extracts export patterns
      - parseFileWithRecovery returns errors array with line numbers
    pitfalls:
      - what: Treating partial AST as fully validated
        instead: Check result.partial flag and handle appropriately
        reason: Partial ASTs may have incomplete or invalid node structures
      - what: Ignoring regex fallback symbols
        instead: Use them despite limitations (better than nothing)
        reason: Some symbol info is better than complete loss for broken files
      - what: Not logging recovery attempts
        instead: Log warnings for partial recovery, errors for complete failures
        reason: Observability helps identify problematic files
    timestamp: 2026-02-02
    evidence: commit 38d4e96, PR #76/#92, app/src/indexer/ast-parser.ts, app/src/indexer/regex-fallback.ts

  extract_symbols:
    when: Extracting functions, classes, interfaces, types from AST
    approach: |
      1. Call extractSymbols(ast, filePath)
      2. Visitor pattern traverses AST
      3. Dispatch based on node.type
         - FunctionDeclaration -> function symbol
         - ClassDeclaration -> class symbol + methods/properties
         - TSInterfaceDeclaration -> interface symbol
         - TSTypeAliasDeclaration -> type symbol
         - TSEnumDeclaration -> enum symbol
         - VariableDeclaration -> variable/constant (if exported)
         - ExportNamedDeclaration -> recurse into declaration
      4. Extract metadata for each symbol
         - name, kind, lineStart, lineEnd, columnStart, columnEnd
         - signature (for functions)
         - documentation (JSDoc extraction)
         - isExported (public API tracking)
         - isAsync, accessModifier (TypeScript features)

      VisitorContext tracks:
      - comments: TSESTree.Comment[] (for JSDoc extraction)
      - parent: TSESTree.Node | null (for export detection)
      - isExported: boolean (current export context)

      Symbol kinds:
      - function, class, interface, type, variable, constant, method, property, enum
    examples:
      - FunctionDeclaration with async -> isAsync: true
      - Class method with private -> accessModifier: "private"
    pitfalls:
      - what: Missing location data (node.loc undefined)
        instead: Guard with if (!node.loc) return
        reason: Some synthetic nodes lack position info
      - what: Extracting non-exported variables
        instead: Only extract exported variables
        reason: Reduces noise in symbol table

  extract_references:
    when: Extracting imports, calls, property access, type references from AST
    approach: |
      1. Call extractReferences(ast, filePath)
      2. Visitor pattern traverses all nodes recursively
      3. Dispatch based on node.type
         - ImportDeclaration -> import references
         - CallExpression -> function/method call references
         - MemberExpression -> property access references
         - TSTypeReference -> TypeScript type references
      4. Extract metadata for each reference
         - targetName, referenceType, lineNumber, columnNumber
         - metadata (importSource, importAlias, isMethodCall, etc.)

      Reference types:
      - import: Named, default, namespace, side-effect imports
      - call: Function calls, method calls
      - property_access: Member expressions (non-call)
      - type_reference: TypeScript type references

      Import handling:
      - Named: import { foo } from './module'
      - Default: import foo from './module'
      - Namespace: import * as foo from './module'
      - Side-effect: import './module'
      - Aliased: import { foo as bar } from './module'
    examples:
      - ImportDeclaration -> multiple Reference objects (one per specifier)
      - CallExpression with MemberExpression -> isMethodCall: true
    pitfalls:
      - what: Not visiting children after extracting reference
        instead: Always call visitChildren for nested references
        reason: Chained calls (obj.foo().bar()) have nested structures
      - what: Extracting computed properties
        instead: Skip computed properties (return null)
        reason: Cannot resolve obj[key] statically

  resolve_imports:
    when: Resolving import paths to absolute file paths (relative and path aliases)
    approach: |
      1. Call resolveImport(importSource, fromFilePath, files, pathMappings)
      2. If starts with ./ or ../ -> relative import resolution
         - Resolve relative to importing file's directory
         - Try extension resolution (.ts, .tsx, .js, .jsx, .mjs, .cjs)
         - Try index file resolution (index.ts, index.tsx, etc.)
         - Return result or null
      3. If pathMappings provided -> path alias resolution
         - Match import against alias patterns (e.g., "@api/*")
         - Try each resolution path for matched alias
         - Check files Set for existence (not filesystem)
         - Return first match or null
      4. Otherwise -> external import (node_modules, etc.)
         - Return null (out of scope)

      Resolution priority:
      1. Relative imports (./ or ../)
      2. Path aliases (tsconfig.json paths)
      3. External imports (null)

      Path alias features (NEW):
      - Parses tsconfig.json/jsconfig.json at project root
      - Supports extends inheritance (recursive, depth-limited)
      - First-match-wins for multi-path mappings
      - Graceful fallback if no config found

    examples:
      - "./utils" -> "/repo/src/utils.ts" (relative)
      - "./api" -> "/repo/src/api/index.ts" (relative with index)
      - "@api/routes" -> "/repo/src/api/routes.ts" (path alias)
      - "lodash" -> null (node_modules, skip)
    pitfalls:
      - what: Resolving node_modules imports
        instead: Return null for non-relative, non-alias imports
        reason: External dependencies handled separately
      - what: Using path.resolve (creates absolute paths)
        instead: Use path.join + path.normalize
        reason: Preserves relative path structure
    timestamp: 2026-01-29
    evidence: app/src/indexer/import-resolver.ts

  resolve_path_aliases:
    when: Resolving path alias imports (@api/*, @db/*, etc.) to absolute file paths
    approach: |
      1. Parse tsconfig.json (or jsconfig.json) at project root
         - Extract compilerOptions.paths and compilerOptions.baseUrl
         - Support extends inheritance (recursive with MAX_EXTENDS_DEPTH = 10)
         - Merge child paths with parent (child takes precedence)
      2. Match import against each alias pattern
         - Exact match (no wildcard): "@api" === "@api"
         - Wildcard match: "@api/*" matches "@api/routes" -> suffix "routes"
      3. Try each resolution path for matched alias (first-match-wins)
         - Substitute wildcard with matched suffix: "src/api/*" -> "src/api/routes"
         - Resolve relative to baseUrl: join(projectRoot, baseUrl, substituted)
         - Normalize path for consistent format
      4. **CRITICAL: Convert absolute path to relative for files Set lookup**
         - After normalize(), path is absolute (e.g., "/repo/src/api/routes")
         - files Set contains relative paths (e.g., "src/api/routes.ts")
         - Convert: `resolved.startsWith(projectRoot) ? resolved.slice(projectRoot.length + 1) : resolved`
         - Use normalized relative path for tryExtensions() and tryIndexFiles()
      5. Try extension variants (.ts, .tsx, .js, .jsx, .mjs, .cjs)
      6. Try index file resolution (index.ts, index.tsx, index.js, index.jsx)
      7. Return first match or null if not found
      
      Project root determination:
      - Walk up directory tree looking for package.json, tsconfig.json, or .git
      - Limit to 10 levels (maxDepth)
      - Fallback to first two path segments if markers not found
      
      Key features:
      - Recursive extends support (child tsconfig extends parent)
      - Circular extends detection with depth limit
      - Fallback from tsconfig.json to jsconfig.json (JavaScript projects)
      - First-match-wins for multi-path mappings (e.g., monorepo fallbacks)
      - Graceful error handling (return null on parse errors)
    examples:
      - "@api/routes" with { "@api/*": ["src/api/*"] } -> "/repo/src/api/routes.ts"
      - "@shared/utils" with { "@shared/*": ["src/shared/*", "packages/shared/*"] } -> first match wins
      - Child tsconfig extends parent -> merges path mappings
    pitfalls:
      - what: Not supporting tsconfig extends
        instead: Parse parent recursively and merge configs
        reason: Monorepos often use base tsconfig with child overrides
      - what: Using existsSync to check resolved paths
        instead: Check against files Set (indexed files only)
        reason: Avoids filesystem access, matches indexed data
      - what: Failing on circular extends
        instead: Implement depth limit and return null gracefully
        reason: Some projects have malformed tsconfig chains
      - what: Testing with mocks
        instead: Use real filesystem fixtures in /tmp
        reason: Antimocking philosophy - test real tsconfig parsing
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts, app/tests/indexer/path-resolver.test.ts

  build_dependencies:
    when: Constructing file-to-file and symbol-to-symbol dependency graph
    approach: |
      1. Call extractDependencies(files, symbols, references, repositoryId)
      2. Build file dependencies from import references
         - Match importSource to resolved file path
         - Create DependencyEdge with fromFileId, toFileId
         - dependencyType: "file_import"
      3. Build symbol dependencies from call references
         - Find caller symbol (containing the call expression)
         - Find callee symbol (function being called)
         - Create DependencyEdge with fromSymbolId, toSymbolId
         - dependencyType: "symbol_usage"

      Helper functions:
      - buildFileDependencies: Import references -> file edges
      - buildSymbolDependencies: Call references -> symbol edges
      - findSymbolByLineNumber: Match line to enclosing symbol

      Ambiguous match handling:
      - Multiple symbols with same name -> prefer same-file match
      - No match found -> log debug, skip edge
      - Missing target -> log warning, continue
    examples:
      - import { foo } from './utils' -> file_import edge
      - foo() inside bar() -> symbol_usage edge from bar to foo
    pitfalls:
      - what: Failing on unresolved references
        instead: Log debug/warning and continue
        reason: External functions, built-ins won't resolve
      - what: Creating self-references
        instead: Skip if fromSymbolId === toSymbolId
        reason: Recursive calls are not useful dependencies

  store_indexed_data:
    when: Persisting extracted data to SQLite database
    approach: |
      1. Call storeIndexedData(repositoryId, files, symbols, references, dependencies)
      2. Single transaction wraps all operations (atomicity)
      3. Insert files and build file_path -> file_id mapping
      4. Insert symbols and build symbol_key -> symbol_id mapping
         - symbol_key format: "file_path::symbol_name::line_start"
      5. Insert references using file/symbol mappings
      6. Return StorageResult with counts

      Storage interface:
      - FileData: path, content, language, size_bytes, metadata
      - SymbolData: file_path, name, kind, line_start, line_end, signature, documentation
      - ReferenceData: source_file_path, target_symbol_key, line_number, reference_type
      - DependencyGraphEntry: from_file_path, to_file_path, dependency_type

      Transaction pattern:
      ```typescript
      db.transaction(() => {
        // All inserts here are atomic
        // Rollback on any failure
      });
      ```
    examples:
      - storeIndexedData(repoId, files, symbols, refs, deps) -> { files_indexed: 10, ... }
    pitfalls:
      - what: Multiple separate transactions
        instead: Single transaction for all operations
        reason: Atomicity guarantees consistency
      - what: Missing file_id lookup for symbol
        instead: Log warning and skip symbol
        reason: Orphan symbols without file reference are useless

  search_indexed_content:
    when: Searching indexed file content with FTS5 full-text search
    approach: |
      1. Accept raw search term from user input
      2. Call escapeFts5Term(term) to sanitize for FTS5 MATCH
         - Escapes internal double quotes by doubling them
         - Wraps entire term in double quotes for exact phrase matching
      3. Use escaped term in FTS5 MATCH clause
         - Prevents operator interpretation (-, AND, OR, NOT)
         - Ensures multi-word phrases match as exact phrase
      4. Return search results with file path, content, and metadata
      
      Escaping pattern:
      ```typescript
      function escapeFts5Term(term: string): string {
        const escaped = term.replace(/"/g, '""');
        return `"${escaped}"`;
      }
      ```
      
      Common edge cases:
      - "pre-commit" → escaped prevents "no such column: commit" error
      - "planType smb" → matches exact phrase, not "planType AND smb"
      - "search and find" → "and" treated as literal, not AND operator
      - 'say "hello"' → embedded quotes doubled to 'say ""hello""'
    examples:
      - escapeFts5Term("pre-commit") → '"pre-commit"'
      - escapeFts5Term("planType smb") → '"planType smb"'
      - FTS5 MATCH with escaped term returns exact phrase matches
    pitfalls:
      - what: Using raw user input directly in MATCH clause
        instead: Always escape with escapeFts5Term
        reason: Hyphens interpreted as NOT, spaces as AND
      - what: Escaping with backslashes (\")
        instead: Double internal quotes ("")
        reason: SQLite FTS5 uses doubling for quote escaping
    timestamp: 2026-01-28
    evidence: commit 5af086f, app/src/api/queries.ts


  batch_process_large_repos:
    when: Indexing repositories with 200+ files to avoid database transaction timeouts
    approach: |
      Chunk files into batches (BATCH_SIZE = 50). Process chunks sequentially with atomic
      transactions per chunk. First chunk performs DELETE+INSERT, subsequent chunks INSERT only.
      Filter symbols/references per chunk by file_path. Accumulate stats across chunks.
      
      Key pattern: skipDelete parameter controls whether to DELETE before INSERT (first chunk only).
    examples:
      - 250-file repository -> 5 chunks of 50 files each, each commits atomically
    pitfalls:
      - what: Deleting on every chunk
        instead: Only DELETE on first chunk (skipDelete parameter)
        reason: Repeated DELETEs cause conflicts and performance issues
    timestamp: 2026-01-28
    evidence: commit d47a650
  filter_build_artifacts:
    when: Discovering source files to avoid indexing build output and dependencies
    approach: |
      IGNORED_DIRECTORIES set (27 directories): .git, node_modules, vendor, build, dist, out,
      target, .next, .vercel, .turbo, .nuxt, .output, .svelte-kit, .angular, .vite, .parcel-cache,
      .nx, coverage, __pycache__, .pytest_cache, venv, .venv, env, .cache
      
      Covers: version control, package managers, build output, framework caches, test coverage, Python envs.
    timestamp: 2026-01-28
    evidence: commit 5a4bca3
  ast_parsing_strategy:
    question: How should I parse this file?
    options:
      - if: File extension is .ts, .tsx, .js, .jsx, .cjs, .mjs
        then: Use parseFile() to get AST
      - if: File extension is .json
        then: Skip AST parsing (data file)
      - if: File extension is unknown
        then: Check isSupportedForAST(), skip if false
      - if: parseFile() returns null
        then: Log warning, continue with other files

  symbol_extraction_approach:
    question: What kind of symbol is this AST node?
    options:
      - if: FunctionDeclaration
        then: Extract function symbol with signature
      - if: ClassDeclaration
        then: Extract class symbol, recurse into methods/properties
      - if: TSInterfaceDeclaration
        then: Extract interface symbol
      - if: TSTypeAliasDeclaration
        then: Extract type symbol
      - if: TSEnumDeclaration
        then: Extract enum symbol
      - if: VariableDeclaration and isExported
        then: Extract variable/constant/function symbol
      - if: ExportNamedDeclaration or ExportDefaultDeclaration
        then: Recurse into declaration with isExported: true
      - if: Other node type
        then: Skip (no symbol to extract)

  reference_extraction_approach:
    question: What kind of reference is this AST node?
    options:
      - if: ImportDeclaration
        then: Extract import reference per specifier
      - if: CallExpression with Identifier callee
        then: Extract function call reference
      - if: CallExpression with MemberExpression callee
        then: Extract method call reference
      - if: MemberExpression (not callee of CallExpression)
        then: Extract property access reference
      - if: TSTypeReference
        then: Extract type reference
      - if: Other node type
        then: Visit children recursively

  import_resolution_strategy:
    question: How should I resolve this import path?
    options:
      - if: Starts with ./ or ../
        then: Relative import, resolve with extensions/index files
      - if: Matches path alias pattern (pathMappings provided)
        then: Resolve using tsconfig.json path mappings
      - if: Starts with / or bare module (no alias match)
        then: Absolute/external import, return null (out of scope)
      - if: Has extension already
        then: Check exact path in files Set
      - if: No extension
        then: Try SUPPORTED_EXTENSIONS in order
      - if: Still not found
        then: Try index file resolution

error_recovery_strategy:
    question: How should I handle parse errors for this file?
    options:
      - if: parseFileWithRecovery returns ast with partial:false
        then: Use AST normally (no errors)
      - if: parseFileWithRecovery returns ast with partial:true
        then: Use partial AST, log warning, extract available symbols
      - if: parseFileWithRecovery returns null with errors
        then: Use regex fallback (extractSymbolsWithRegex)
      - if: Regex fallback returns empty array
        then: Log error, skip file (no symbols available)
      - if: Symbol has metadata.extractionMethod: "regex"
        then: Use with caution (may lack JSDoc, accurate positions)

patterns:
  visitor_pattern:
    structure: |
      function visitNode(node, results, context): void {
        const childContext = { ...context, parent: node };
        switch (node.type) {
          case "SpecificNodeType":
            extractFromNode(node, results, context);
            break;
          default:
            visitChildren(node, results, childContext);
        }
      }
  graceful_error_handling:
    structure: |
      try {
        return parse(content, options);
      } catch (error) {
        logger.error("Failed to parse", error, { file_path: filePath });
        Sentry.captureException(error, { tags: { module: "ast-parser" } });
        return null;  // Graceful failure
      }
  jsdoc_extraction:
    structure: |
      Extract last block comment before node within 5 lines.
      Strip /** */ and leading * from each line.
    trade_offs:
      pros: [Preserves documentation, Position-based matching]
      cons: [5-line heuristic may miss some comments]


  tsconfig_extends_pattern:
    structure: |
      function parseTsConfigWithExtends(
        configPath: string,
        depth: number,
        maxDepth: number
      ): TsConfig | null {
        // Prevent infinite recursion
        if (depth >= maxDepth) {
          logger.warn("Circular extends detected");
          return null;
        }
        
        const config = JSON.parse(readFileSync(configPath, "utf-8"));
        
        // No extends - return as-is
        if (!config.extends) return config;
        
        // Parse parent config
        const extendsPath = isAbsolute(config.extends)
          ? config.extends
          : join(dirname(configPath), config.extends);
        
        // Add .json extension if missing
        const resolved = extendsPath.endsWith(".json")
          ? extendsPath
          : `${extendsPath}.json`;
        
        const parent = parseTsConfigWithExtends(resolved, depth + 1, maxDepth);
        
        // Merge parent and child configs
        return mergeTsConfigs(config, parent);
      }
      
      function mergeTsConfigs(child: TsConfig, parent: TsConfig): TsConfig {
        return {
          ...parent,
          ...child,
          compilerOptions: {
            ...parent.compilerOptions,
            ...child.compilerOptions,
            paths: {
              ...parent.compilerOptions?.paths,
              ...child.compilerOptions?.paths,  // Child overrides parent
            }
          }
        };
      }
    trade_offs:
      pros: [Supports monorepo base configs, Matches tsc behavior, Prevents infinite loops]
      cons: [Recursive parsing overhead, Depth limit may miss deep chains]
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts

  path_alias_integration_pattern:
    structure: |
      // 1. Parse tsconfig at workflow start
      const pathMappings = parseTsConfig(projectRoot);
      if (pathMappings) {
        logger.info("Loaded path mappings", {
          aliasCount: Object.keys(pathMappings.paths).length,
          baseUrl: pathMappings.baseUrl
        });
      }
      
      // 2. Pass through resolution pipeline
      const resolved = resolveImport(
        importSource,
        fromFilePath,
        files,
        pathMappings  // Optional parameter
      );
      
      // 3. Store resolved path in database
      if (resolved) {
        targetFilePath = normalizePath(resolved);
      }
    trade_offs:
      pros: [Single parse per indexing run, Optional enhancement (graceful if null), Clean parameter threading]
      cons: [Additional parameter in call chain, Null handling complexity]
    timestamp: 2026-01-29
    evidence: app/src/api/queries.ts runIndexingWorkflow()



  constant_extraction:
    when: Shared constants need synchronization across modules
    approach: |
      Place in dedicated constants.ts with 'as const' for type safety.
      Document synchronization requirements in JSDoc with "IMPORTANT" marker.
      Export priority-ordered arrays (TypeScript variants first).
      Note modules that must stay synchronized.
    timestamp: 2026-01-29
    evidence: app/src/indexer/constants.ts

  ast_parsing:
    - Use @typescript-eslint/parser for modern TypeScript support
    - Always enable loc, range, comment, tokens options
    - Return null on parse error (never throw)
    - Log errors with file path for debugging
    - Check isSupportedForAST before parsing

  symbol_extraction:
    - Use visitor pattern for consistent traversal
    - Track export context through visitor context
    - Extract JSDoc comments for documentation
    - Include position info (line/column) for navigation
    - Handle anonymous functions gracefully (<anonymous>)

  reference_extraction:
    - Visit children after extracting reference (for nested references)
    - Skip computed properties (cannot resolve statically)
    - Distinguish function calls from method calls
    - Track optional chaining (?.) in metadata

  import_resolution:
    - Resolve relative imports (./ and ../) AND path aliases (@alias/*)
    - Parse tsconfig.json once at indexing start (not per file)
    - Pass pathMappings through entire resolution pipeline
    - Try relative resolution first, then path alias resolution
    - Return null for unresolvable imports (node_modules, missing configs)
    - Use path.join + path.normalize (NOT path.resolve)
    - Check files Set instead of filesystem (indexed files only)
    - Support jsconfig.json fallback for JavaScript projects
    - Handle extends recursively with circular detection
    - Try extensions in priority order (.ts first)
    - Handle index file resolution
    - Preserve relative path structure for database matching
    timestamp: 2026-01-29
    evidence: app/src/indexer/import-resolver.ts, app/src/indexer/path-resolver.ts
  storage:
    - Use single transaction for atomicity
    - Build lookup maps for efficient foreign key resolution
    - Generate UUIDs for primary keys
    - Log storage results for observability

  fts5_search:
    - Always escape user search terms before FTS5 MATCH queries
    - Wrap terms in double quotes for exact phrase matching
    - Escape internal quotes by doubling them ("" not \")
    - Prevents SQL errors on hyphens, spaces, AND/OR/NOT keywords
    - Test with: hyphenated-terms, multi-word phrases, FTS keywords
    timestamp: 2026-01-28
    evidence: commit 5af086f

  logging:
    - Use createLogger({ module: "indexer-<name>" })
    - Log errors with structured metadata
    - Use debug level for expected failures (unresolved imports)
    - Use warn level for unexpected but recoverable failures
    - Never use console.* (use process.stdout.write for raw output)

known_issues:
  - issue: path.resolve() converts relative to absolute paths
    impact: Import resolution fails when database stores relative paths
    resolution: Use path.join() + path.normalize() to preserve relative structure
    prevention: |
      Never use path.resolve() in import resolution.
      Always use: path.normalize(path.join(fromDir, importSource))
    status: resolved
    timestamp: 2026-01-28
    evidence: commit 5713a52

  - issue: tsconfig.json path mapping not supported
    impact: Absolute imports with path aliases not resolved
    resolution: Implemented in path-resolver.ts with full extends support
    status: resolved
    timestamp: 2026-01-29
    evidence: app/src/indexer/path-resolver.ts

  - issue: Schema CHECK constraint must match all reference types
    impact: Insertion failures when reference extractor produces new types
    resolution: property_access was missing from CHECK constraint list
    prevention: When adding reference types: update extractor, schema, tests
    status: resolved
    timestamp: 2026-01-28
    evidence: commit 91415ad

  - issue: Path alias resolution used absolute paths for files Set lookup
    impact: resolvePathAlias() failed to find files despite correct resolution
    resolution: |
      Convert absolute paths to relative before files Set lookup.
      Code: `resolved.startsWith(projectRoot) ? resolved.slice(projectRoot.length + 1) : resolved`
    prevention: |
      files Set ALWAYS contains relative paths (no leading slash).
      After join(projectRoot, ...) + normalize(), convert to relative for lookup.
      Pass relative path to tryExtensions() and tryIndexFiles().
    status: resolved
    timestamp: 2026-01-31
    evidence: commit 644fbc9, app/src/indexer/path-resolver.ts lines 265-268, app/tests/indexer/path-resolver.test.ts (added relative path test)

stability:
  convergence_indicators:
    insight_rate_trend: stable
    contradiction_count: 0
    new_patterns_added_this_cycle: 2
    patterns_updated_this_cycle: 2
    last_reviewed: 2026-02-02
    utility_ratio: 1.0
    notes: |
      Cycle 6 update - AST parser error recovery (focus_area: error recovery):
      - Added: parse_ast_with_error_recovery operation (3-stage recovery: normal -> partial AST -> regex)
      - Added: error_recovery_cascade_pattern (graceful degradation pattern)
      - Added: error_recovery_strategy decision tree
      - Updated: core_implementation/key_files to include regex-fallback.ts
      - Learning: allowInvalidAST enables partial recovery; regex fallback prevents complete symbol loss
      - Evidence: commit 38d4e96, PR #76/#92, 1538 lines changed across 11 files
      - File size managed: 980 -> 1167 (pre-prune) -> 844 (post-prune, target range)
      - Pruned: storage_abstraction, batch_transaction, test_fixture patterns (lower value/redundant)
      
      Cycle 5 (2026-01-31) - path resolver bug fix:
      - Updated: resolve_path_aliases with critical path normalization
      - Added: known_issues entry for absolute-to-relative conversion bug (#62)
      - File size: ~950 -> ~975 lines

