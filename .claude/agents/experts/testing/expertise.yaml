# Testing Expertise for KotaDB
# Target: 400-600 lines | Domain: Operational knowledge for Bun test runner and antimocking patterns
# Adapted for KotaDB project conventions

overview:
  description: |
    Testing expertise for KotaDBâ€”Bun test runner (Jest-compatible API), antimocking philosophy
    with real SQLite databases, in-memory database patterns, and test lifecycle management.
    This expertise enables correct test implementation within the KotaDB codebase conventions.
  scope: |
    Covers Bun test runner configuration and usage, antimocking philosophy (real SQLite, no mocks),
    in-memory SQLite database patterns (":memory:"), test lifecycle hooks (beforeAll, beforeEach,
    afterEach, afterAll), test organization patterns, and KotaDB-specific testing conventions.

    KOTADB ADAPTATIONS:
    - Uses Bun test runner with Jest-compatible API (describe, test, expect)
    - Antimocking philosophy - always use real implementations over mocks
    - In-memory SQLite via createDatabase({ path: ":memory:" })
    - Schema auto-initialization from sqlite-schema.sql
    - Logging uses process.stdout.write (never console.*)
    - Local-only SQLite storage (no cloud dependencies)
    - Path aliases (@api/*, @db/*, @indexer/*, etc.) in imports

    Does NOT cover agent prompt content authoring (see agent-authoring expert).
  rationale: |
    The antimocking philosophy produces more reliable tests by exercising real code paths.
    In-memory SQLite provides fast, isolated test environments without filesystem overhead.
    Consistent lifecycle management ensures proper setup and cleanup across test suites.

core_implementation:
  test_structure:
    app/tests/:
      purpose: Application-level tests
      unit/: Unit tests for isolated functions
      integration/: Cross-module integration tests
      api/: API endpoint tests
      indexer/: Indexing functionality tests
      validation/: Schema and validation tests
    app/src/**/__tests__/:
      purpose: Colocated tests next to source files
      pattern: Tests live alongside the modules they test

  key_patterns:
    - pattern: describe/test blocks
      usage: Group related tests with describe, individual tests with test or it
    - pattern: In-memory SQLite
      usage: createDatabase({ path: ":memory:" }) for fast isolated tests
    - pattern: beforeEach/afterEach
      usage: Setup and cleanup per test for isolation
    - pattern: Real implementations
      usage: Never mock - use actual SQLite, actual functions

  test_file_naming:
    convention: "<module-name>.test.ts"
    examples:
      - queries-sqlite.test.ts
      - sqlite-client.test.ts
      - symbol-extractor.test.ts
    location_patterns:
      colocated: "src/<module>/__tests__/<name>.test.ts"
      centralized: "tests/<category>/<name>.test.ts"

key_operations:
  write_sqlite_test:
    when: Testing any code that interacts with the database
    approach: |
      1. Import test utilities from bun:test
         ```typescript
         import { describe, expect, test, beforeEach, afterEach } from "bun:test";
         ```
      2. Import database factory
         ```typescript
         import { createDatabase, type KotaDatabase } from "@db/sqlite/index.js";
         ```
      3. Set up test lifecycle
         ```typescript
         describe("Feature Name", () => {
           let db: KotaDatabase;
           const testRepoId = "test-repo-123";

           beforeEach(() => {
             // Create fresh in-memory database for each test
             db = createDatabase({ path: ":memory:" });
             // Insert test data as needed
             db.run("INSERT INTO repositories (id, name, full_name) VALUES (?, ?, ?)",
               [testRepoId, "test-repo", "owner/test-repo"]);
           });

           afterEach(() => {
             if (db) {
               db.close();
             }
           });

           test("should do something", () => {
             // Test implementation
           });
         });
         ```
      4. Use real database operations in tests
      5. Assert on actual database state
    pitfalls:
      - what: "Forgetting to close database in afterEach"
        instead: "Always close db in afterEach to prevent resource leaks"
        reason: "Memory leaks and potential test interference"
      - what: "Using beforeAll for database setup"
        instead: "Use beforeEach for per-test isolation"
        reason: "Tests should not share database state"
      - what: "Mocking the database"
        instead: "Use real in-memory SQLite"
        reason: "Antimocking philosophy ensures real code paths tested"

  apply_antimocking_philosophy:
    when: Writing any test in KotaDB
    principles:
      - name: Real over Mock
        description: |
          Always prefer real implementations over mocks. If testing database code,
          use real SQLite. If testing API handlers, use real database state.
      - name: In-memory for Speed
        description: |
          Use in-memory SQLite (":memory:") for fast test execution without
          filesystem overhead. Each test gets a fresh database.
      - name: Isolation through Fresh State
        description: |
          Create new database instances in beforeEach, not beforeAll. This ensures
          complete isolation between tests without complex cleanup logic.
      - name: Real Schema
        description: |
          The createDatabase() function auto-initializes the schema from sqlite-schema.sql.
          Tests exercise the real schema, catching schema-related bugs.
    examples:
      bad: |
        // DON'T DO THIS - mocking violates antimocking philosophy
        const mockDb = {
          query: jest.fn().mockReturnValue([{ id: 1 }]),
          run: jest.fn(),
        };
      good: |
        // DO THIS - use real in-memory database
        const db = createDatabase({ path: ":memory:" });
        db.run("INSERT INTO users (id, name) VALUES (?, ?)", ["1", "Alice"]);
        const result = db.query("SELECT * FROM users WHERE id = ?", ["1"]);
        expect(result).toHaveLength(1);

  manage_test_lifecycle:
    when: Setting up test suites
    hooks:
      beforeAll: |
        Use sparingly. Good for one-time expensive setup that doesn't affect test isolation.
        Example: Creating temporary directories for file-based tests.
        ```typescript
        let tempDir: string;
        beforeAll(() => {
          tempDir = mkdtempSync(join(tmpdir(), "kota-test-"));
        });
        ```
      beforeEach: |
        Primary hook for test setup. Use for per-test isolation.
        Example: Creating fresh in-memory database.
        ```typescript
        let db: KotaDatabase;
        beforeEach(() => {
          db = createDatabase({ path: ":memory:" });
        });
        ```
      afterEach: |
        Cleanup after each test. Essential for resource management.
        Example: Closing database connections.
        ```typescript
        afterEach(() => {
          if (db) db.close();
        });
        ```
      afterAll: |
        Final cleanup. Good for removing temp directories.
        Example: Removing temporary test directories.
        ```typescript
        afterAll(() => {
          rmSync(tempDir, { recursive: true, force: true });
        });
        ```
    lifecycle_order:
      - beforeAll (once per describe block)
      - beforeEach (before each test)
      - test execution
      - afterEach (after each test)
      - afterAll (once per describe block)

  write_api_test:
    when: Testing API endpoints or handlers
    approach: |
      1. Create in-memory database with test data
      2. Import and call handler functions directly
      3. Assert on responses and database state
      ```typescript
      describe("API Handler", () => {
        let db: KotaDatabase;

        beforeEach(() => {
          db = createDatabase({ path: ":memory:" });
          // Seed test data
        });

        afterEach(() => {
          db?.close();
        });

        test("should return expected response", async () => {
          // Call handler directly with test database
          const result = await handlerFunction(db, testInput);
          expect(result.status).toBe(200);
          // Verify database state changed correctly
        });
      });
      ```

  write_indexer_test:
    when: Testing symbol extraction, reference extraction, or parsing
    approach: |
      1. Use real parsers with test source code
      2. Create inline test fixtures
      3. Assert on extracted data structures
      ```typescript
      describe("Symbol Extractor", () => {
        test("should extract function symbols", () => {
          const source = `
            export function greet(name: string): string {
              return \`Hello, \${name}!\`;
            }
          `;
          const symbols = extractSymbols(source, "test.ts");
          expect(symbols).toContainEqual(
            expect.objectContaining({
              name: "greet",
              kind: "function",
            })
          );
        });
      });
      ```
  test_fts5_search_queries:
    when: Testing FTS5 search functionality
    approach: |
      1. Always test edge cases with special characters and FTS5 operators
      2. Cover hyphenated terms, multi-word phrases, FTS keywords as literals
      3. Verify proper escaping of user input
      ```typescript
      describe("searchFilesLocal - FTS edge cases", () => {
        test("should search hyphenated terms without SQL errors", () => {
          // Tests like "pre-commit" that can be misinterpreted as "pre NOT commit"
          const results = searchFilesLocal(db, "pre-commit", testRepoId, 10);
          expect(Array.isArray(results)).toBe(true);
        });
        
        test("should search FTS keywords (AND, OR, NOT) as literals", () => {
          // FTS5 keywords should be treated as literal search terms
          const resultsAnd = searchFilesLocal(db, "search and find", testRepoId, 10);
          expect(Array.isArray(resultsAnd)).toBe(true);
        });
      });
      ```
    timestamp: 2026-01-28
    evidence: commit 5af086f (Issue #595)
    rationale: |
      FTS5 interprets hyphens as NOT operators and keywords like "and/or/not" as
      query syntax. Tests must verify proper escaping to prevent SQL errors on
      user-provided search terms.

  test_environment_variable_restoration:
    when: Testing code that depends on environment variables
    approach: |
      1. Store original environment variables before modification
      2. Restore them in afterAll, even if test fails
      3. Delete variables that weren't originally set (avoid undefined pollution)
      ```typescript
      describe("Local Mode Tests", () => {
        const originalEnv = {
          KOTADB_PATH: process.env.KOTADB_PATH,
          KOTA_LOCAL_MODE: process.env.KOTA_LOCAL_MODE,
        };
        
        beforeAll(() => {
          process.env.KOTADB_PATH = testDbPath;
          process.env.KOTA_LOCAL_MODE = "true";
        });
        
        afterAll(() => {
          // Restore or delete to prevent pollution
          if (originalEnv.KOTADB_PATH !== undefined) {
            process.env.KOTADB_PATH = originalEnv.KOTADB_PATH;
          } else {
            delete process.env.KOTADB_PATH;
          }
        });
      });
      ```
    timestamp: 2026-01-28
    evidence: app/src/api/__tests__/local-indexing.test.ts
    rationale: |
      Environment pollution between test suites causes unpredictable failures.
      Proper restoration ensures test isolation at the process environment level.

  test_filesystem_workflows:
    when: Testing indexing or file-based workflows end-to-end
    approach: |
      1. Create isolated temp directories with unique identifiers (randomUUID)
      2. Test with real file operations (writeFileSync, mkdirSync)
      3. Clean up with closeGlobalConnections() before directory removal
      4. Use existsSync guard before rmSync to handle cleanup errors gracefully
      ```typescript
      describe("Local Indexing Workflow", () => {
        const testId = randomUUID().slice(0, 8);
        const testDir = join(process.cwd(), \`.test-indexing-temp-\${testId}\`);
        
        beforeAll(() => {
          mkdirSync(testDir, { recursive: true });
        });
        
        afterAll(() => {
          closeGlobalConnections(); // Critical before directory removal
          if (existsSync(testDir)) {
            rmSync(testDir, { recursive: true, force: true });
          }
        });
        
        test("indexes local directory successfully", async () => {
          const projectDir = join(testDir, "sample-project");
          mkdirSync(projectDir, { recursive: true });
          writeFileSync(join(projectDir, "sample.ts"), sampleContent);
          
          const result = await runIndexingWorkflowLocal({
            repository: "test-project",
            localPath: projectDir,
          });
          
          expect(result.filesIndexed).toBeGreaterThanOrEqual(1);
        });
      });
      ```
    timestamp: 2026-01-28
    evidence: app/src/api/__tests__/local-indexing.test.ts
    rationale: |
      Real filesystem operations test the full indexing workflow including file
      discovery, parsing, and database storage. Unique temp directories prevent
      test interference. Global connection cleanup prevents EBUSY errors.

  test_security_boundaries:
    when: Testing path-based operations with security implications
    approach: |
      1. Write explicit security tests for path traversal attempts
      2. Document acceptable security outcomes (error vs zero results)
      3. Verify the attack path actually escapes the intended boundary
      ```typescript
      test("rejects path traversal attempts", async () => {
        const workspaceRoot = resolve(testDir);
        const traversalPath = join(testDir, "..", "..", "..", "..", "tmp");
        const resolvedTraversal = resolve(traversalPath);
        
        // Sanity check: path actually escapes workspace
        expect(resolvedTraversal.startsWith(workspaceRoot)).toBe(false);
        
        let threw = false;
        let filesIndexed = -1;
        try {
          const result = await runIndexingWorkflowLocal({
            repository: "traversal-attempt",
            localPath: traversalPath,
          });
          filesIndexed = result.filesIndexed;
        } catch {
          threw = true;
        }
        
        // Either throw OR index 0 files (both acceptable)
        expect(threw || filesIndexed === 0).toBe(true);
      });
      ```
    timestamp: 2026-01-28
    evidence: app/src/api/__tests__/local-indexing.test.ts
    rationale: |
      Security tests must explicitly verify that attack vectors fail safely.
      Document acceptable outcomes to prevent false positives during refactoring.

  skip_schema_initialization_for_custom_schemas:
    when: Tests need to manage their own schema (migrations, sync tests)
    approach: |
      Use skipSchemaInit option to prevent auto-initialization conflicts:
      ```typescript
      db = createDatabase({ 
        path: join(tempDir, "test.db"), 
        skipSchemaInit: true 
      });
      // Apply custom schema
      db.exec(customSchemaSQL);
      ```
    timestamp: 2026-01-28
    evidence: commit d669841, sync integration tests
    rationale: |
      Some tests need to control schema initialization timing (migrations,
      sync tests with custom schemas). skipSchemaInit prevents conflicts
      with auto-initialization from sqlite-schema.sql.
  create_sqlite_test_fixtures:
    when: Creating reusable test data for database-dependent tests
    approach: |
      Use typed fixture factory functions from app/tests/helpers/db.ts to create
      realistic test data with minimal boilerplate. This pattern eliminates the need
      for manual INSERT statements while maintaining type safety.

      1. Import fixture helpers
         ```typescript
         import {
           getTestDatabase,
           createTestRepository,
           createTestFile,
           createTestSymbol,
           createTestReference,
           createFullTestFixture,
           TestRepository,
           TestFile,
         } from "../helpers/db.js";
         ```
      2. Create fixtures with defaults + overrides
         ```typescript
         describe("Repository Search", () => {
           let db: KotaDatabase;
           let repo: TestRepository;
           let files: TestFile[];

           beforeEach(() => {
             db = getTestDatabase();
             // Create repository with custom name
             repo = createTestRepository(db, {
               name: "my-custom-repo",
               owner: "test-org"
             });
             // Create multiple files
             files = [
               createTestFile(db, repo.id, { path: "src/index.ts" }),
               createTestFile(db, repo.id, { path: "src/utils.ts" }),
             ];
           });

           afterEach(() => {
             db?.close();
           });

           test("searches across files", () => {
             const results = searchRepository(db, repo.id, "function");
             expect(results.length).toBeGreaterThan(0);
           });
         });
         ```
      3. For comprehensive multi-entity fixtures, use createFullTestFixture
         ```typescript
         const fixture = createFullTestFixture(db, {
           fileCount: 5,
           symbolsPerFile: 3,
         });
         // Returns: { repository, files[], symbols[], references[] }
         ```
    pitfalls:
      - what: "Manual INSERT statements when fixtures exist"
        instead: "Use createTestRepository, createTestFile, etc. helpers"
        reason: "Fixtures provide type safety, documentation, and consistency"
      - what: "Creating fixtures in beforeAll"
        instead: "Create fresh fixtures in beforeEach or each test"
        reason: "Tests should not share fixture state"
      - what: "Hardcoding UUIDs or timestamps"
        instead: "Let fixtures generate them with randomUUID and new Date()"
        reason: "Unique IDs prevent cross-test collisions"
    timestamp: 2026-01-28
    evidence: Issue #607, app/tests/helpers/db.ts (complete rewrite)
    rationale: |
      The migration from Supabase to SQLite revealed the need for reusable fixture
      patterns. Typed factory functions reduce boilerplate while maintaining
      expressiveness. The fixture pattern scales well as test coverage expands.

  simplify_test_environment_setup:
    when: Configuring test environment via setup.ts
    approach: |
      After SQLite migration, test environment setup is dramatically simplified.
      No global state or external service dependencies are needed.

      1. Minimal setup.ts - rely on per-test isolation
         ```typescript
         // app/tests/setup.ts
         // No global setup needed for SQLite in-memory tests
         // Each test creates its own isolated database instance

         // Optional: Set default test timeout
         // Bun.jest.setTimeout(30000);

         // Optional: Global test hooks can be added here if needed
         // import { beforeAll, afterAll } from "bun:test";
         // beforeAll(async () => { ... });
         // afterAll(async () => { ... });
         ```
      2. Previous pattern (deprecated - don't use):
         - No need to load .env.test files
         - No need to reset rate limit counters globally
         - No need for service client initialization
      3. All setup moves to individual test files
         ```typescript
         beforeEach(() => {
           db = getTestDatabase(); // Fresh database per test
         });
         afterEach(() => {
           db?.close();
         });
         ```
    benefits:
      - Eliminates global state pollution between tests
      - No external service dependencies (Supabase, PostgreSQL)
      - Faster test startup (no environment variable parsing)
      - Per-test isolation is automatic via in-memory databases
      - Simpler CI configuration (no .env.test, no service containers)
    timestamp: 2026-01-28
    evidence: Issue #607, commit d669841, app/tests/setup.ts
    rationale: |
      Local-only SQLite architecture eliminates the need for centralized environment
      setup. In-memory databases provide complete test isolation without shared state.
      This pattern is more reliable than previous Supabase-based approach.

  test_mcp_endpoints_locally:
    when: Testing MCP (Model Context Protocol) endpoints in local mode
    approach: |
      After removing Supabase, MCP tests no longer need authentication headers.
      Simplify test setup by removing tier-based authentication.

      1. Old pattern (pre-migration, deprecated):
         ```typescript
         // DON'T DO THIS - authentication was required before migration
         const response = await sendMcpRequest(
           baseUrl,
           "tools/call",
           params,
           "team" // tier parameter - no longer needed
         );
         ```
      2. New pattern (local-only, post-migration):
         ```typescript
         import { sendMcpRequest, extractToolResult } from "../helpers/mcp.js";

         describe("MCP Tools", () => {
           test("calls search tool successfully", async () => {
             const response = await sendMcpRequest(
               "http://localhost:3000",
               "tools/call",
               {
                 name: "search_codebase",
                 arguments: { query: "function greet" }
               }
               // No tier parameter needed - auth is implicit in local mode
             );

             const result = extractToolResult(response.data);
             expect(result.matches).toBeDefined();
             expect(Array.isArray(result.matches)).toBe(true);
           });
         });
         ```
      3. Headers are automatically set (no auth needed)
         ```typescript
         export function createMcpHeaders(): Record<string, string> {
           return {
             "Content-Type": "application/json",
             Accept: "application/json, text/event-stream",
             // Authorization header removed - local mode is always authenticated
           };
         }
         ```
    key_changes:
      - Removed tier parameter from sendMcpRequest() signature
      - Removed createAuthHeader() dependency
      - Removed tier parameter from createMcpHeaders()
      - All local mode requests are automatically authenticated
    timestamp: 2026-01-28
    evidence: Issue #607, app/tests/helpers/mcp.ts
    rationale: |
      Local-only mode doesn't require API key authentication. Removing auth headers
      simplifies test code and eliminates a source of test failures related to
      authentication setup.

  clean_up_temp_directories_with_unique_identifiers:
    when: Testing file-based operations that create temporary directories
    approach: |
      Use randomUUID().slice(0, 8) to create unique prefixes for test directories.
      This prevents collisions when tests run in parallel.

      1. Create temp directory with unique prefix
         ```typescript
         import { mkdtempSync, rmSync, existsSync } from "node:fs";
         import { join } from "node:path";
         import { tmpdir } from "node:os";
         import { randomUUID } from "node:crypto";

         describe("File Processing", () => {
           const testId = randomUUID().slice(0, 8);
           const tempDir = join(tmpdir(), \`kota-test-\${testId}\`);

           beforeAll(() => {
             mkdtempSync(tempDir, { recursive: true });
           });

           afterAll(() => {
             if (existsSync(tempDir)) {
               rmSync(tempDir, { recursive: true, force: true });
             }
           });

           test("processes files in directory", () => {
             // Test implementation using tempDir
           });
         });
         ```
      2. Benefits of unique prefixes:
         - Parallel test execution doesn't cause collisions
         - Failed cleanup doesn't block subsequent test runs
         - Easy to identify stale test artifacts on disk
         - Deterministic cleanup with existsSync guard
    timestamp: 2026-01-28
    evidence: Issue #607, app/tests/helpers/db.ts (createTempDir, cleanupTempDir)
    rationale: |
      Unique directory prefixes prevent race conditions in parallel test execution.
      The existsSync guard provides graceful error handling if cleanup partially fails.

decision_trees:
  test_type_selection:
    question: What type of test should I write?
    options:
      - if: Testing a single function in isolation
        then: Unit test with minimal setup
      - if: Testing database queries or mutations
        then: SQLite test with in-memory database
      - if: Testing multiple modules working together
        then: Integration test with full database setup
      - if: Testing API endpoint behavior
        then: API test with seeded database state
      - if: Testing file parsing or extraction
        then: Indexer test with inline fixtures

  sqlite_database_choice:
    question: How should I set up the database?
    options:
      - if: Testing database interactions
        then: |
          Use in-memory database with beforeEach
          ```typescript
          db = createDatabase({ path: ":memory:" });
          ```
      - if: Testing file persistence or WAL mode
        then: |
          Use temp directory with file-based database
          ```typescript
          const dbPath = join(tempDir, "test.db");
          db = createDatabase({ path: dbPath });
          ```
      - if: Testing concurrent access
        then: |
          Use file-based database with multiple connections
          Ensure proper cleanup in afterAll

  assertion_strategy:
    question: How should I assert test results?
    options:
      - if: Checking exact values
        then: "expect(value).toBe(expected)"
      - if: Checking object properties
        then: "expect(obj).toEqual({ key: value })"
      - if: Checking array contains item
        then: "expect(arr).toContainEqual(expected)"
      - if: Checking object has property
        then: "expect(obj).toHaveProperty('key')"
      - if: Checking async throws
        then: "expect(async () => await fn()).rejects.toThrow()"
      - if: Checking null/undefined
        then: "expect(value).toBeNull() or expect(value).toBeDefined()"

patterns:
  sqlite_test_pattern:
    structure: |
      import { describe, expect, test, beforeEach, afterEach } from "bun:test";
      import { createDatabase, type KotaDatabase } from "@db/sqlite/index.js";

      describe("Feature", () => {
        let db: KotaDatabase;

        beforeEach(() => {
          db = createDatabase({ path: ":memory:" });
          // Seed data
        });

        afterEach(() => {
          db?.close();
        });

        test("should work", () => {
          // Arrange, Act, Assert
        });
      });
    trade_offs:
      pros: [Fast execution, Complete isolation, Real code paths, Schema validation]
      cons: [No persistence between tests, Must seed data each test]

  file_based_test_pattern:
    structure: |
      import { describe, expect, it, beforeAll, beforeEach, afterEach, afterAll } from "bun:test";
      import { mkdtempSync, rmSync } from "node:fs";
      import { join } from "node:path";
      import { tmpdir } from "node:os";

      describe("File-based Feature", () => {
        let tempDir: string;
        let db: KotaDatabase;

        beforeAll(() => {
          tempDir = mkdtempSync(join(tmpdir(), "kota-test-"));
        });

        beforeEach(() => {
          const dbPath = join(tempDir, "test.db");
          db = createDatabase({ path: dbPath });
        });

        afterEach(() => {
          db?.close();
        });

        afterAll(() => {
          rmSync(tempDir, { recursive: true, force: true });
        });

        it("should persist data", () => {
          // Test file persistence
        });
      });
    use_when:
      - Testing WAL mode behavior
      - Testing file path resolution
      - Testing concurrent database access
      - Testing database migration scenarios

  nested_describe_pattern:
    structure: |
      describe("Module", () => {
        let db: KotaDatabase;

        beforeEach(() => {
          db = createDatabase({ path: ":memory:" });
        });

        afterEach(() => {
          db?.close();
        });

        describe("method1()", () => {
          test("should handle case A", () => {});
          test("should handle case B", () => {});
        });

        describe("method2()", () => {
          test("should handle case A", () => {});
          test("should handle case B", () => {});
        });
      });
    trade_offs:
      pros: [Clear organization, Shared setup, Readable output]
      cons: [Deep nesting can reduce clarity]

  data_driven_test_pattern:
    structure: |
      describe("Language Detection", () => {
        const cases = [
          { file: "app.ts", expected: "typescript" },
          { file: "app.js", expected: "javascript" },
          { file: "app.py", expected: "python" },
          { file: "app.go", expected: "go" },
        ];

        test.each(cases)("should detect $expected for $file", ({ file, expected }) => {
          expect(detectLanguage(file)).toBe(expected);
        });
      });
    use_when:
      - Testing many similar cases with different inputs
      - Mapping file extensions to languages
      - Validating multiple input/output pairs

best_practices:
  organization:
    - Group related tests with describe blocks
    - Use descriptive test names that explain expected behavior
    - Follow "should do X when Y" naming pattern
    - Keep test files colocated with source or in centralized tests/ directory

  isolation:
    - Create fresh database in beforeEach, not beforeAll
    - Close database connections in afterEach
    - Never rely on test execution order
    - Each test should be independently runnable

  antimocking:
    - NEVER mock database operations - use real in-memory SQLite
    - NEVER mock file system for database tests - use temp directories
    - NEVER mock module imports - use real implementations
    - EXCEPTION - External services (if any) may use controlled test doubles

  assertions:
    - Assert on actual database state, not just return values
    - Use specific assertions (toBe, toEqual) over generic (toBeTruthy)
    - Check error conditions with expect().rejects or try/catch
    - Verify side effects (database changes) after operations

  performance:
    - In-memory SQLite provides fast test execution
    - Avoid unnecessary setup in beforeEach
    - Use beforeAll only for truly shared, immutable setup
    - Parallelize independent test suites

  kotadb_conventions:
    - Import from path aliases (@api/*, @db/*, @indexer/*, @shared/*)
    - Use process.stdout.write for any logging (never console.*)
    - Include JSDoc comment at top of test file describing coverage
    - Follow existing test patterns in the codebase

known_issues:
  - issue: Database connection not closed in test
    impact: Resource leaks, potential test interference
    resolution: Always close db in afterEach
    prevention: Use the standard test pattern with afterEach cleanup
    status: enforce via code review

  - issue: Tests depend on execution order
    impact: Flaky tests that pass/fail inconsistently
    resolution: Use beforeEach for all state setup
    prevention: Each test creates its own fresh state
    status: enforce via code review

  - issue: Mocking database operations
    impact: Tests pass but production code fails
    resolution: Use real in-memory SQLite
    prevention: Antimocking philosophy is mandatory
    status: enforced via code review

  - issue: Schema changes not reflected in tests
    impact: Tests use outdated schema
    resolution: createDatabase() auto-initializes from sqlite-schema.sql
    prevention: Always use createDatabase() helper
    status: automatic via factory function

  - issue: Temp files not cleaned up
    impact: Disk space accumulation, stale test artifacts
    resolution: Use afterAll to clean temp directories
    prevention: Use mkdtempSync/rmSync pattern
    status: enforce via code review


  - issue: FTS5 search terms with special characters cause SQL errors
    impact: User searches with hyphens or FTS keywords fail with SQL syntax errors
    resolution: Escape search terms by wrapping in double quotes and doubling internal quotes
    prevention: Test FTS5 edge cases - hyphens, multi-word, FTS keywords, embedded quotes
    status: resolved via escapeFts5Term() (commit 5af086f)
    timestamp: 2026-01-28
potential_enhancements:
  - Custom test reporter for antimocking compliance
  - Schema validation assertions
  - Test coverage tracking per module
  - Performance benchmarking for database operations
  - Test data factory helpers for common entities

bun_test_api:
  imports: |
    import { describe, expect, test, it, beforeAll, beforeEach, afterEach, afterAll } from "bun:test";
  assertions:
    toBe: Strict equality (===)
    toEqual: Deep equality for objects/arrays
    toBeTruthy: Value is truthy
    toBeFalsy: Value is falsy
    toBeNull: Value is null
    toBeDefined: Value is not undefined
    toBeUndefined: Value is undefined
    toContain: Array/string contains value
    toContainEqual: Array contains matching object
    toHaveLength: Array/string has length
    toHaveProperty: Object has property
    toThrow: Function throws error
    toMatchObject: Object matches subset
    toBeGreaterThan: Number comparison
    toBeLessThan: Number comparison
  async:
    await_in_test: "test('async', async () => { await fn(); })"
    rejects: "expect(async () => await fn()).rejects.toThrow()"
  skip_and_focus:
    skip: "test.skip('skipped', () => {})"
    only: "test.only('focused', () => {})"
    todo: "test.todo('not yet implemented')"

stability:
  convergence_indicators:
    insight_rate_trend: increasing
    contradiction_count: 0
    new_patterns_added_this_cycle: 9
    patterns_updated_this_cycle: 0
    last_reviewed: 2026-01-28
    utility_ratio: 1.0
    notes: |
      Second improve cycle - SQLite migration learnings extraction.
      
      Previous cycle (first):
      - Added 5 new key_operations from recent commits (5af086f, d669841)
      - FTS5 edge case testing patterns (Issue #595)
      - Environment variable restoration for test isolation
      - Filesystem workflow testing with real file operations
      - Security boundary testing for path traversal
      - skipSchemaInit option for custom schema tests
      
      This cycle (SQLite migration focus):
      - Created SQLite test fixtures pattern (typed factory functions)
      - Simplified test environment setup (removed Supabase/Postgres dependencies)
      - Local-only MCP testing without authentication headers
      - Unique identifier pattern for temp directory cleanup
      - Complete migration from Supabase to SQLite test infrastructure
      - Issue #607 and #591 learnings incorporated
      
      Total patterns in expertise: 13 key_operations
      Domain stability: Moderate (SQLite migration patterns now established)
