# KotaDB API Expert Knowledge
# Target: 400-600 lines | Domain: Operational knowledge for API development
# Adapted for KotaDB local-only architecture

overview:
  description: |
    KotaDB API expertise covering Express HTTP server patterns, MCP SDK integration with
    StreamableHTTPServerTransport, OpenAPI specification generation, CLI entry point, 
    and query layer patterns. This expertise enables correct API endpoint, MCP tool, 
    and CLI command implementation within KotaDB's local-only, SQLite-based architecture.
  scope: |
    Covers Express app structure (app/src/api/), route patterns, MCP server and transport
    configuration, MCP tool definitions and executors, OpenAPI spec generation with Zod schemas,
    CLI entry point (app/src/cli.ts), query layer functions for SQLite, and middleware patterns.

    KOTADB ADAPTATIONS:
    - Local-only mode (no Supabase, no cloud auth)
    - SQLite database via getGlobalDatabase()
    - Authentication bypassed in local mode
    - Synchronous operations (no queue)
    - MCP uses StreamableHTTPServerTransport with JSON mode
    - Path aliases (@api/*, @mcp/*, @db/*, @logging/*, etc.)
    - Logging via process.stdout.write (never console.*)
    - CLI entry point via bin field in package.json
  rationale: |
    Consistent API implementation enables reliable MCP tool usage and proper endpoint design.
    CLI patterns ensure seamless npm package distribution. Poor structure leads to 
    inconsistent responses, broken tool contracts, and difficult debugging.

core_implementation:
  key_files:
    - path: app/src/cli.ts
      purpose: CLI entry point - argument parsing, server startup, graceful shutdown
      exports: (none - direct execution)
      patterns: shebang, arg parsing, signal handlers, version resolution
    - path: app/src/api/routes.ts
      purpose: Express app factory - createExpressApp()
      exports: createExpressApp
    - path: app/src/api/queries.ts
      purpose: SQLite query functions - searchFiles, listRecentFiles, runIndexingWorkflow
      exports: searchFiles, listRecentFiles, ensureRepository, saveIndexedFiles
    - path: app/src/mcp/server.ts
      purpose: MCP Server factory - createMcpServer(), createMcpTransport()
      exports: createMcpServer, createMcpTransport
    - path: app/src/mcp/tools.ts
      purpose: MCP tool definitions and executors
      exports: SEARCH_CODE_TOOL, executeSearchCode, handleToolCall, etc.
    - path: app/src/api/openapi/builder.ts
      purpose: OpenAPI 3.1 spec generator
      exports: buildOpenAPISpec, clearSpecCache

key_operations:
  create_cli_entry_point:
    when: Creating npm bin entry point for distributed package
    approach: |
      1. Create app/src/cli.ts with #!/usr/bin/env bun shebang (first line, no BOM)
      2. Import createExpressApp, getEnvironmentConfig, createLogger
      3. Implement getVersion(): Reads package.json at runtime
      4. Implement parseArgs() to handle --help, -h, --version, -v, --port <number>
      5. In main(): parse args -> handle --version/--help -> start server
      6. Set up graceful shutdown handlers for SIGTERM and SIGINT:
         - Close server and exit(0) on success
         - Force exit(1) after 10-second timeout
      7. Add global error handlers for unhandledRejection and uncaughtException
      8. Export cli.ts in package.json bin field: { "kotadb": "./src/cli.ts" }
    timestamp: 2026-01-28
    evidence: app/src/cli.ts (full implementation)
    rationale: |
      Enables KotaDB distribution as installable npm package via `npx kotadb` or `bunx kotadb`.
      Bun shebang allows direct execution. Graceful shutdown prevents database corruption.
    key_patterns:
      - getVersion() reads package.json at runtime (supports bundled packages)
      - process.argv.slice(2) skips executable and script path
      - Timeout-based forced shutdown (10s) prevents hanging processes
      - process.stdout.write for output, process.stderr.write for errors
    pitfalls:
      - what: "Using console.log instead of process.stdout.write"
        instead: "Use process.stdout.write for all CLI output"
        reason: "console.log adds overhead, process.stdout.write is pure"
      - what: "Hardcoding package version in CLI code"
        instead: "Read from package.json at runtime"
        reason: "Must stay in sync with package.json during releases"
      - what: "Missing timeout in shutdown handler"
        instead: "Always include 10-second timeout for forced shutdown"
        reason: "Prevents process hanging if close() doesn't complete"

  add_express_route:
    when: Adding new HTTP endpoint to the API
    approach: |
      1. Add route inside createExpressApp() in app/src/api/routes.ts
      2. Use AuthenticatedRequest for authenticated routes, Request for public
      3. Always call addRateLimitHeaders(res, context.rateLimit) before response
      4. Extract and validate query params early, return 400 on missing params
      5. Call query functions from @api/queries, handle errors with 500 status
      6. Register in OpenAPI spec via app/src/api/openapi/paths.ts
    examples:
      - GET /search (authenticated, rate-limited)
      - POST /mcp (public, JSON-RPC)
      - GET /health (public, no auth)
    pitfalls:
      - what: "Forgetting addRateLimitHeaders call"
        instead: "Always call it before sending response"
        reason: "Clients expect rate limit headers on all endpoints"

  register_mcp_tool:
    when: Adding new MCP tool for Claude Code integration
    approach: |
      1. Define ToolDefinition in app/src/mcp/tools.ts with name, description, inputSchema
      2. Create executor function: validate params -> call query functions -> return result
      3. Register in createMcpServer: add to ListToolsRequestSchema and CallToolRequestSchema
      4. Validate ALL parameters including types before processing
      5. Return structured objects that serialize well to JSON
    examples:
      - search_code: searches indexed files using FTS5
      - index_repository: runs indexing workflow
      - list_recent_files: lists recently indexed files with optional filtering
    pitfalls:
      - what: "Missing parameter validation"
        instead: "Always type-check all params before using"
        reason: "LLM may pass incorrect parameters"

  add_query_function:
    when: Adding new database query operation
    approach: |
      1. Create internal function with db parameter (for testability)
      2. Create public function using getGlobalDatabase()
      3. Internal functions: db.query<T>(), db.queryOne<T>(), db.run(), db.transaction()
      4. Use db.prepare() for bulk operations
      5. Always escape FTS5 terms with escapeFts5Term() for user input
    kotadb_conventions:
      - Use getGlobalDatabase() from @db/sqlite/index.js for public functions
      - Internal functions take db parameter for testing
      - Transaction wrapper via db.transaction(() => { ... })
      - Prepared statements for bulk inserts

  implement_fts5_search:
    when: Adding or modifying FTS5 full-text search operations
    approach: |
      1. Always escape user input: escapeFts5Term(term) wraps in double quotes
      2. Use FTS5 MATCH operator with escaped terms
      3. Use bm25() for relevance ranking and snippet() for context
      4. Test edge cases: hyphenated terms, multi-word phrases, FTS5 keywords, quotes
    rationale: |
      Prevents SQL errors on multi-word phrases, hyphens, and FTS5 keywords.
      Double-quote escaping forces exact phrase matching and treats input as literal.
    pitfalls:
      - what: "Passing raw user input to MATCH"
        instead: "Always use escapeFts5Term() first"
        reason: "Unescaped input breaks FTS5 query parsing"

  validate_local_file_paths:
    when: Accepting file paths in local mode API operations
    approach: |
      1. Use path.resolve(localPath) to convert to absolute path
      2. Verify path.startsWith(process.cwd()) to prevent traversal attacks
      3. Check fs.existsSync(resolvedPath) if needed
    rationale: |
      Local mode indexing accepts user-provided paths. Without validation,
      "../../../etc/passwd" could expose sensitive files. Restrict all paths 
      to within process.cwd() workspace directory.

  add_optional_parameter_filters:
    when: Adding optional filtering parameters to query functions and MCP tools
    approach: |
      1. Create internal function with optional parameter (e.g., repositoryId?: string)
      2. Use hasFilter flag to control both SQL string AND params array
      3. Type guard in executor: validate optional param type before using
      4. Extract with safe casting: (params.prop as string | undefined)
      5. Document optional parameter in tool inputSchema with description
    timestamp: 2026-01-28
    evidence: Issue #608 (repository filtering for list_recent_files)
    rationale: |
      Enables multi-repository support without breaking backward compatibility.
      hasRepoFilter conditional pattern avoids dynamic SQL and ensures parameter 
      arrays match query placeholders.
    pitfalls:
      - what: "Parameter array length mismatch with SQL placeholders"
        instead: "Use hasFilter flag to control both SQL and params"
        reason: "Mismatched params cause binding errors"

  test_mcp_tool:
    when: Testing MCP tool implementations for correctness and edge cases
    approach: |
      1. Create <tool-name>.test.ts (unit) and <tool-name>.integration.test.ts (integration)
      2. Unit tests: parameter validation, error cases, type checking
      3. Integration tests: database operations using KOTADB_PATH env var
      4. Cover: parameter validation, empty/populated results, optional params, edge cases
    timestamp: 2026-01-28
    evidence: commit 8156491 (43 tests across 8 MCP tools)
    rationale: |
      Two-tier approach ensures parameter validation and database operations work.
      KOTADB_PATH allows file-based test databases, working around global singleton.
    pitfalls:
      - what: "Using in-memory databases with getGlobalDatabase()"
        instead: "Use KOTADB_PATH env var for file-based test database"
        reason: "Global singleton needs file path for proper isolation"


  configure_npm_package_distribution:
    when: Publishing TypeScript package with path aliases for direct execution (Bun/ts-node)
    approach: |
      1. Include tsconfig.json in package.json files array (required for alias resolution)
      2. Relocate shared dependencies from external monorepo siblings into package root
      3. Update path aliases in tsconfig.json to reference internal paths
      4. Add all aliased directories to files array (e.g., "shared/**/*.ts")
      5. Add all aliased directories to tsconfig.json include array
      6. Update monorepo workspace configuration to remove relocated packages
      7. Update CI workflows to remove separate type-checking steps for relocated code
      8. Test locally: npm pack -> bunx <tarball> to verify module resolution
    timestamp: 2026-01-29
    evidence: Issue #39, pending changes for v2.0.1
    rationale: |
      When Bun executes TypeScript directly (not transpiled), it uses tsconfig.json to
      resolve path aliases at runtime. Without this file in the published package, imports
      like @api/routes fail with "Cannot find module" errors. External path aliases
      (../shared/*) break because npm only publishes files within package directory.
    key_patterns:
      - tsconfig.json MUST be in files array for runtime alias resolution
      - Path aliases must reference internal paths (./shared/*, not ../shared/*)
      - All aliased directories must be included in both files array AND include array
      - Test with npm pack + bunx before publishing to catch resolution issues
    pitfalls:
      - what: "Excluding tsconfig.json from published package"
        instead: "Always include tsconfig.json in files array"
        reason: "Bun needs it to resolve path aliases at runtime"
      - what: "Path aliases pointing outside package root (../shared/*)"
        instead: "Relocate dependencies into package or reference internally (./shared/*)"
        reason: "npm only publishes files within package directory"
      - what: "Adding to files array but not include array"
        instead: "Add aliased directories to BOTH files and include arrays"
        reason: "Type-checking needs include, runtime needs files"
      - what: "Publishing without local testing"
        instead: "Always test with npm pack + bunx <tarball> first"
        reason: "Catches module resolution issues before public publish"
    affected_files: |
      When restructuring for npm distribution:
      - app/package.json (files array, version bump)
      - app/tsconfig.json (paths, include array)
      - package.json (workspaces array if monorepo)
      - .github/workflows/npm-publish.yml (CI adjustments)

patterns:
  cli_entry_point_pattern:
    structure: |
      // app/src/cli.ts (with #!/usr/bin/env bun shebang on first line)
      function getVersion(): string {
        const packageJsonPath = join(__dirname, "..", "package.json");
        const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf-8"));
        return packageJson.version || "unknown";
      }
      
      function parseArgs(args: string[]): CliOptions {
        const options: CliOptions = { port: 3000, help: false, version: false };
        for (let i = 0; i < args.length; i++) {
          if (args[i] === "--help" || args[i] === "-h") options.help = true;
          else if (args[i] === "--version" || args[i] === "-v") options.version = true;
          else if (args[i] === "--port") options.port = Number(args[++i]);
        }
        return options;
      }
      
      async function main(): Promise<void> {
        const options = parseArgs(process.argv.slice(2));
        if (options.version) {
          process.stdout.write(`kotadb v${getVersion()}\n`);
          process.exit(0);
        }
        const server = createExpressApp().listen(options.port);
        const shutdown = () => {
          server.close(() => process.exit(0));
          setTimeout(() => process.exit(1), 10000);
        };
        process.on("SIGTERM", shutdown);
        process.on("SIGINT", shutdown);
      }
    notes:
      - First line MUST be #!/usr/bin/env bun (no BOM)
      - process.argv.slice(2) skips executable and script path
      - getVersion() reads package.json at runtime
      - Use process.stdout.write / process.stderr.write (not console.*)
      - 10-second timeout in shutdown handler
    timestamp: 2026-01-28
    evidence: app/src/cli.ts

  express_route_pattern:
    structure: |
      app.get("/path", async (req: AuthenticatedRequest, res: Response) => {
          const context = req.authContext!;
          const param = req.query.param as string;
          if (!param) {
              addRateLimitHeaders(res, context.rateLimit);
              return res.status(400).json({ error: "Missing param" });
          }
          const results = queryFunction(param);
          addRateLimitHeaders(res, context.rateLimit);
          res.json({ results });
      });
    notes:
      - AuthenticatedRequest for authenticated routes
      - Always addRateLimitHeaders before response
      - Return early with status code on validation failure

  mcp_tool_pattern:
    structure: |
      export const TOOL_NAME: ToolDefinition = {
          name: "tool_name",
          description: "When/why to use",
          inputSchema: {
              type: "object",
              properties: { param: { type: "string", description: "..." } },
              required: ["param"],
          },
      };
      
      export async function executeTool(
          params: unknown,
          _requestId: string | number,
          userId: string,
      ): Promise<unknown> {
          if (typeof params !== "object" || params === null)
              throw new Error("Parameters must be an object");
          const p = params as Record<string, unknown>;
          if (p.param === undefined) throw new Error("Missing: param");
          return await queryFunction(p.param as string);
      }
    notes:
      - Tool description guides LLM on when/how to use
      - Properties need descriptions in inputSchema
      - Validate all params including types and ranges

  sqlite_query_pattern:
    structure: |
      function queryInternal(db: KotaDatabase, param: string): Result[] {
          const sql = `SELECT * FROM table WHERE condition = ? LIMIT ?`;
          const rows = db.query<RowType>(sql, [param, 20]);
          return rows.map(transform);
      }
      export function query(param: string): Result[] {
          return queryInternal(getGlobalDatabase(), param);
      }
    notes:
      - Internal function takes db param (testable)
      - Public function uses getGlobalDatabase()
      - db.query<T>(), db.queryOne<T>(), db.run(), db.transaction(), db.prepare()

  fts5_search_pattern:
    structure: |
      function escapeFts5Term(term: string): string {
          return `"${term.replace(/"/g, '""')}"`;
      }
      function searchInternal(db: KotaDatabase, term: string): Result[] {
          const sql = `
              SELECT f.*, snippet(fts, 1, '<mark>', '</mark>', '...', 32) AS snippet
              FROM table_fts fts
              JOIN table f ON fts.rowid = f.rowid
              WHERE table_fts MATCH ?
              ORDER BY bm25(table_fts) LIMIT 100
          `;
          return db.query<Result>(sql, [escapeFts5Term(term)]);
      }
    notes:
      - Always escape with escapeFts5Term before MATCH
      - Use bm25() for relevance, snippet() for context
      - Test: hyphens, phrases, FTS5 keywords, quotes

  npm_package_files_pattern:
    structure: |
      // app/package.json (TypeScript package with path aliases for Bun)
      {
        "name": "kotadb",
        "version": "2.0.1",
        "bin": {
          "kotadb": "./src/cli.ts"
        },
        "files": [
          "src/**/*.ts",
          "src/**/*.js",
          "!src/**/*.test.ts",
          "!src/**/*.spec.ts",
          "tsconfig.json",        // Required for path alias resolution
          "shared/**/*.ts"        // Include all aliased dependencies
        ]
      }
      
      // app/tsconfig.json
      {
        "compilerOptions": {
          "baseUrl": ".",
          "paths": {
            "@api/*": ["src/api/*"],
            "@shared/*": ["./shared/*"]  // Internal reference, not ../shared/*
          }
        },
        "include": [
          "src/**/*.ts",
          "tests/**/*.ts",
          "shared/**/*.ts"  // Must include aliased directories
        ]
      }
    notes:
      - tsconfig.json in files array enables runtime path alias resolution
      - All path aliases must reference internal paths relative to package root
      - Aliased directories must appear in BOTH files and include arrays
      - Test with npm pack + bunx before publishing
      - Alternative: transpile to JS with resolved imports (different trade-offs)
    timestamp: 2026-01-29
    evidence: Issue #39 fix for v2.0.1


best_practices:
  cli: |
    - Include #!/usr/bin/env bun shebang on first line (no BOM)
    - Use process.stdout.write for output, process.stderr.write for errors
    - Read version from package.json at runtime, not hardcoded
    - Register BOTH SIGTERM and SIGINT handlers
    - Include 10-second forced shutdown timeout
  
  routes: |
    - Always addRateLimitHeaders before response
    - Extract and validate params early
    - Use AuthenticatedRequest for authenticated routes
    - Return JSON errors: { error: "message" }
  
  mcp: |
    - Tool descriptions explain when/why to use
    - Validate ALL parameters including types
    - Return structured objects that serialize to JSON
    - Log tool calls with tool_name and user_id
  
  queries: |
    - Internal functions take db param (testable)
    - Public functions use getGlobalDatabase()
    - Always escape FTS5 terms with escapeFts5Term()
    - Use transactions for multi-statement operations
  
  testing: |
    - Unit tests: parameter validation, error cases
    - Integration tests: database operations with KOTADB_PATH
    - Aim for 5-8 tests per tool covering all paths
    - Clear test data in afterEach
  
  npm_distribution: |
    - Include tsconfig.json in files array for path alias resolution
    - Relocate external dependencies into package root (./shared/*, not ../shared/*)
    - Add aliased directories to BOTH files and include arrays
    - Test with npm pack + bunx <tarball> before publishing
    - Update CI workflows when restructuring monorepo packages


known_issues:
  - issue: OpenAPI spec cached at startup
    impact: Changes not reflected until restart
    status: by-design for performance
    resolution: Call clearSpecCache() during development

  - issue: FTS5 syntax errors from unescaped input
    impact: "no such column" errors on hyphenated/multi-word searches
    status: resolved (2026-01-28, commit 5af086f)
    resolution: Always use escapeFts5Term() before MATCH

  - issue: npm package missing tsconfig.json and shared types
    impact: bunx kotadb fails with "Cannot find module @api/routes" 
    status: resolved (2026-01-29, Issue #39)
    resolution: Include tsconfig.json and shared/**/*.ts in files array, relocate shared/ into app/

stability:
  convergence_indicators:
    insight_rate_trend: stable
    contradiction_count: 0
    new_patterns_added_this_cycle: 2
    patterns_updated_this_cycle: 0
    last_reviewed: 2026-01-29
    utility_ratio: 1.0
    notes: |
      Sixth review cycle - npm package distribution patterns:
      
      New operation: configure_npm_package_distribution
      - Complete guidance on TypeScript package publishing with Bun
      - tsconfig.json inclusion, path alias management, monorepo restructuring
      
      New pattern: npm_package_files_pattern
      - Template for package.json files array and tsconfig.json configuration
      
      Previously stable patterns:
      - CLI entry point (Issue #19)
      - Optional parameter filtering (Issue #608)
      - MCP tool testing patterns
      - FTS5 search term escaping
      - Local file path validation
      - Local auth bypass
      
      Architecture stability: Very High
      - Zero contradictions across 6 cycles
      - All core operations documented
      - All 8 MCP tools with comprehensive tests
      - CLI deployment pattern established
      - npm distribution patterns now comprehensive
      
      Next review: After 10-15 API commits or next npm distribution issue

