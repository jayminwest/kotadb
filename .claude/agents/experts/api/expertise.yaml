# KotaDB API Expert Knowledge
# Target: 400-600 lines | Domain: Operational knowledge for API development
# Adapted for KotaDB local-only architecture

overview:
  description: |
    KotaDB API expertise covering Express HTTP server patterns, MCP SDK integration with
    StreamableHTTPServerTransport, OpenAPI specification generation, route organization,
    and query layer patterns. This expertise enables correct API endpoint and MCP tool
    implementation within KotaDB's local-only, SQLite-based architecture.
  scope: |
    Covers Express app structure (app/src/api/), route patterns, MCP server and transport
    configuration, MCP tool definitions and executors, OpenAPI spec generation with Zod schemas,
    query layer functions for SQLite, middleware patterns (CORS, logging, error handling), and
    authentication bypass in local mode.

    KOTADB ADAPTATIONS:
    - Local-only mode (no Supabase, no cloud auth)
    - SQLite database via getGlobalDatabase()
    - Authentication bypassed in local mode
    - Synchronous operations (no queue)
    - MCP uses StreamableHTTPServerTransport with JSON mode
    - Path aliases (@api/*, @mcp/*, @db/*, @logging/*, etc.)
    - Logging via process.stdout.write (never console.*)

    Does NOT cover frontend/web UI (no frontend in local mode) or orchestration patterns.
  rationale: |
    Consistent API implementation enables reliable MCP tool usage, proper HTTP endpoint design,
    and maintainable query patterns. Poor API structure leads to inconsistent responses,
    broken tool contracts, and difficult debugging.

core_implementation:
  directory_structure:
    app/src/:
      api/:
        purpose: HTTP routes and Express app factory
        routes.ts: Express app factory with all routes registered
        queries.ts: SQLite query layer for all data operations
        openapi/:
          builder.ts: OpenAPI 3.1 spec generator
          paths.ts: Path operation registrations
          schemas.ts: Zod schemas for request/response validation
        auto-reindex.ts: Auto-reindex functionality for file watching
      mcp/:
        purpose: MCP server and tool implementations
        server.ts: MCP Server factory and StreamableHTTPServerTransport
        tools.ts: Tool definitions (ToolDefinition) and execute* functions
        impact-analysis.ts: Change impact analysis logic
        spec-validation.ts: Implementation spec validation
        jsonrpc.ts: JSON-RPC error helpers
        lifecycle.ts: Session lifecycle management
        headers.ts: MCP header utilities
        session.ts: Session management
      auth/:
        middleware.ts: Authentication middleware (bypassed in local mode)
      logging/:
        logger.ts: Structured logger factory
        middleware.ts: Request/error logging middleware
        context.ts: Logging context management
      db/:
        client.ts: Database client factory
        sqlite/:
          index.ts: SQLite database exports
          sqlite-client.ts: KotaDatabase class implementation

  key_files:
    - path: app/src/api/routes.ts
      purpose: Express app factory - createExpressApp()
      exports: createExpressApp
    - path: app/src/api/queries.ts
      purpose: SQLite query functions - searchFiles, listRecentFiles, runIndexingWorkflow
      exports: searchFiles, listRecentFiles, ensureRepository, saveIndexedFiles, etc.
    - path: app/src/mcp/server.ts
      purpose: MCP Server factory - createMcpServer(), createMcpTransport()
      exports: createMcpServer, createMcpTransport
    - path: app/src/mcp/tools.ts
      purpose: MCP tool definitions and executors
      exports: SEARCH_CODE_TOOL, executeSearchCode, handleToolCall, etc.
    - path: app/src/api/openapi/builder.ts
      purpose: OpenAPI spec generator
      exports: buildOpenAPISpec, clearSpecCache

key_operations:
  add_express_route:
    when: Adding new HTTP endpoint to the API
    approach: |
      1. Open app/src/api/routes.ts
      2. Add route inside createExpressApp() function after existing routes
      3. Pattern for authenticated route:
         ```typescript
         app.get("/endpoint", async (req: AuthenticatedRequest, res: Response) => {
             const context = req.authContext!;
             // Validate query params
             // Call query function from @api/queries
             addRateLimitHeaders(res, context.rateLimit);
             res.json({ results });
         });
         ```
      4. Pattern for public route (health, openapi):
         ```typescript
         app.get("/public-endpoint", (_req: Request, res: Response) => {
             res.json({ data });
         });
         ```
      5. Register in OpenAPI spec via app/src/api/openapi/paths.ts
    examples:
      - endpoint: GET /search
        location: routes.ts line 146
      - endpoint: POST /mcp
        location: routes.ts line 220
    pitfalls:
      - what: "Forgetting addRateLimitHeaders call"
        instead: "Always call addRateLimitHeaders with context.rateLimit"
        reason: "Clients expect rate limit headers on all authenticated endpoints"
      - what: "Using console.log instead of logger"
        instead: "Use createLogger from @logging/logger"
        reason: "Logging standard requires structured JSON output"

  register_mcp_tool:
    when: Adding new MCP tool for Claude Code integration
    approach: |
      1. Define tool in app/src/mcp/tools.ts:
         ```typescript
         export const NEW_TOOL: ToolDefinition = {
             name: "tool_name",
             description: "Tool description for LLM",
             inputSchema: {
                 type: "object",
                 properties: {
                     param: { type: "string", description: "..." },
                 },
                 required: ["param"],
             },
         };
         ```
      2. Create executor function:
         ```typescript
         export async function executeNewTool(
             params: unknown,
             requestId: string | number,
             userId: string,
         ): Promise<unknown> {
             // Validate params structure
             if (typeof params !== "object" || params === null) {
                 throw new Error("Parameters must be an object");
             }
             const p = params as Record<string, unknown>;
             // Validate required params
             // Call query functions from @api/queries
             return { result };
         }
         ```
      3. Register in createMcpServer (app/src/mcp/server.ts):
         - Add to ListToolsRequestSchema handler
         - Add case to CallToolRequestSchema handler switch
      4. Export tool and executor from tools.ts
      5. Add to getToolDefinitions() return array
    examples:
      - tool: search_code
        definition: SEARCH_CODE_TOOL
        executor: executeSearchCode
      - tool: index_repository
        definition: INDEX_REPOSITORY_TOOL
        executor: executeIndexRepository
    pitfalls:
      - what: "Returning raw objects instead of content blocks"
        instead: "MCP response must be { content: [{ type: 'text', text: JSON.stringify(result) }] }"
        reason: "SDK expects content blocks format"
      - what: "Missing validation of required parameters"
        instead: "Always check for undefined/null and correct types"
        reason: "LLM may pass incorrect parameters"

  update_openapi_schema:
    when: Documenting new endpoint or updating existing
    approach: |
      1. Define Zod schemas in app/src/api/openapi/schemas.ts:
         ```typescript
         export const NewResponseSchema = z.object({
             results: z.array(z.object({
                 field: z.string(),
             })),
         });
         ```
      2. Register path in app/src/api/openapi/paths.ts:
         ```typescript
         registry.registerPath({
             method: "get",
             path: "/endpoint",
             tags: ["Category"],
             summary: "Short summary",
             description: "Longer description",
             security: [{ apiKey: [] }],
             responses: {
                 200: {
                     description: "Success",
                     content: {
                         "application/json": {
                             schema: NewResponseSchema,
                         },
                     },
                 },
             },
         });
         ```
      3. Clear cached spec after changes: clearSpecCache()
    examples:
      - schema: SearchResponseSchema
        location: schemas.ts
    pitfalls:
      - what: "Forgetting to clear spec cache during development"
        instead: "Call clearSpecCache() or restart server"
        reason: "OpenAPI spec is cached at startup"

  add_query_function:
    when: Adding new database query operation
    approach: |
      1. Open app/src/api/queries.ts
      2. Create internal function with db parameter:
         ```typescript
         function queryInternal(
             db: KotaDatabase,
             param: string,
         ): Result[] {
             const sql = `SELECT ... FROM ... WHERE ...`;
             const rows = db.query<ResultRow>(sql, [param]);
             return rows.map(transformRow);
         }
         ```
      3. Create public function using getGlobalDatabase():
         ```typescript
         export function query(param: string): Result[] {
             return queryInternal(getGlobalDatabase(), param);
         }
         ```
      4. Optionally add backward-compatible Local variant for tests:
         ```typescript
         export function queryLocal(db: KotaDatabase, param: string): Result[] {
             return queryInternal(db, param);
         }
         ```
    kotadb_conventions:
      - Use getGlobalDatabase() from @db/sqlite/index.js for public functions
      - Internal functions take db parameter for testability
      - Transaction wrapper via db.transaction(() => { ... })
      - Prepared statements via db.prepare() for bulk operations
      - FTS5 search with escapeFts5Term() for user input
    examples:
      - function: searchFiles
        internal: searchFilesInternal
        public: searchFiles
        local: searchFilesLocal

  implement_fts5_search:
    when: Adding or modifying FTS5 full-text search operations
    approach: |
      1. Define escapeFts5Term() helper if not present:
         ```typescript
         function escapeFts5Term(term: string): string {
             // Escape internal double quotes by doubling them
             const escaped = term.replace(/"/g, '""');
             // Wrap in double quotes for exact phrase matching
             return `"${escaped}"`;
         }
         ```
      2. Use FTS5 table with MATCH operator and escaped terms:
         ```typescript
         function searchInternal(db: KotaDatabase, term: string): Result[] {
             const sql = `
                 SELECT f.*, snippet(table_fts, 1, '<mark>', '</mark>', '...', 32) AS snippet
                 FROM table_fts fts
                 JOIN table f ON fts.rowid = f.rowid
                 WHERE table_fts MATCH ?
                 ORDER BY bm25(table_fts)
                 LIMIT ?
             `;
             const escapedTerm = escapeFts5Term(term);
             return db.query<Result>(sql, [escapedTerm, 100]);
         }
         ```
      3. Test edge cases:
         - Hyphenated terms: "pre-commit", "mom-and-pop"
         - Multi-word phrases: "planType smb"
         - FTS5 keywords as literals: "search and find", "OR", "NOT"
         - Embedded quotes: 'say "hello"'
         - Operator-like terms: "AND", "NEAR"
    timestamp: 2026-01-28
    evidence: commit 5af086f
    rationale: |
      Prevents SQL errors when users search for multi-word phrases, hyphenated terms,
      or FTS5 reserved keywords. Without escaping, FTS5 interprets:
      - Spaces as AND operators (e.g., "planType smb" becomes planType AND smb)
      - Hyphens as NOT operators (e.g., "pre-commit" becomes pre NOT commit)
      - Keywords (AND, OR, NOT) as query syntax instead of literals
      
      Wrapping in double quotes forces exact phrase matching and treats all input as literals.
    pitfalls:
      - what: "Passing raw user input directly to FTS5 MATCH"
        instead: "Always use escapeFts5Term() before MATCH"
        reason: "FTS5 syntax errors break search functionality"
      - what: "Using single quotes for FTS5 escaping"
        instead: "Use double quotes - they're the FTS5 standard"
        reason: "Single quotes don't prevent operator interpretation"

  validate_local_file_paths:
    when: Accepting file paths in local mode API operations
    approach: |
      1. Import path and fs modules
      2. Validate path is within workspace:
         ```typescript
         import path from "node:path";
         
         function validateLocalPath(localPath: string): void {
             const workspaceRoot = process.cwd();
             const resolvedPath = path.resolve(localPath);
             
             if (!resolvedPath.startsWith(workspaceRoot)) {
                 throw new Error(`Path traversal detected: ${localPath} is outside workspace`);
             }
         }
         ```
      3. Check directory/file existence if needed:
         ```typescript
         import fs from "node:fs";
         
         if (!fs.existsSync(resolvedPath)) {
             throw new Error(`Path does not exist: ${localPath}`);
         }
         ```
      4. Use validated path for indexing/reading operations
    timestamp: 2026-01-28
    evidence: commit efecf9c (PR #589 review feedback)
    rationale: |
      Local mode indexing accepts user-provided file paths. Without validation,
      malicious paths like "../../../etc/passwd" could expose sensitive files.
      Restrict all paths to within process.cwd() workspace directory.
    pitfalls:
      - what: "Trusting user-provided paths without validation"
        instead: "Always validate with path.resolve() and startsWith()"
        reason: "Path traversal attacks can read arbitrary files"
      - what: "Using relative paths directly"
        instead: "Resolve to absolute paths before validation"
        reason: "Relative paths can bypass naive validation"

  add_optional_parameter_filters:
    when: Adding optional filtering parameters to query functions and MCP tools
    approach: |
      1. In query layer (app/src/api/queries.ts), create internal function with optional parameter:
         ```typescript
         function listRecentFilesInternal(
             db: KotaDatabase,
             limit: number,
             repositoryId?: string,
         ): IndexedFile[] {
             const hasRepoFilter = repositoryId !== undefined;
             const sql = hasRepoFilter
                 ? `
                     SELECT ... FROM indexed_files
                     WHERE repository_id = ?
                     ORDER BY indexed_at DESC
                     LIMIT ?
                 `
                 : `
                     SELECT ... FROM indexed_files
                     ORDER BY indexed_at DESC
                     LIMIT ?
                 `;
             
             const params = hasRepoFilter ? [repositoryId, limit] : [limit];
             const rows = db.query<ResultType>(sql, params);
             return rows.map(transformRow);
         }
         ```
         
      2. In MCP tool (app/src/mcp/tools.ts), add type guard for optional parameters:
         ```typescript
         function isListRecentParams(params: unknown): 
             params is { limit?: number; repository?: string } | undefined {
             if (params === undefined) return true;
             if (typeof params !== "object" || params === null) return false;
             const p = params as Record<string, unknown>;
             if (p.limit !== undefined && typeof p.limit !== "number") return false;
             if (p.repository !== undefined && typeof p.repository !== "string") return false;
             return true;
         }
         ```
      
      3. Extract optional parameter in executor with safe casting:
         ```typescript
         const repository =
             params && typeof params === "object" && "repository" in params 
                 ? (params.repository as string | undefined) 
                 : undefined;
         ```
      
      4. Update tool schema to document optional parameter:
         ```typescript
         export const LIST_RECENT_FILES_TOOL: ToolDefinition = {
             name: "list_recent_files",
             description: "List recently indexed files...",
             inputSchema: {
                 type: "object",
                 properties: {
                     limit: {
                         type: "number",
                         description: "Optional: Maximum number of files (default: 10)",
                     },
                     repository: {
                         type: "string",
                         description: "Optional: Filter results to a specific repository ID",
                     },
                 },
             },
         };
         ```
      
      5. Pass optional parameter through to query function:
         ```typescript
         const files = listRecentFiles(limit, repository);
         ```

    timestamp: 2026-01-28
    evidence: Issue #608 (repository filtering for list_recent_files)
    related_files:
      - app/src/mcp/tools.ts (lines 344-351 type guard, 482-500 executor)
      - app/src/api/queries.ts (lines 328-372 listRecentFilesInternal)
      - app/tests/mcp/list-recent-files.test.ts (repository filtering tests)
    
    rationale: |
      Optional parameter filtering enables multi-repository support without breaking
      backward compatibility. The hasRepoFilter conditional pattern avoids SQL concatenation
      and ensures parameter arrays always match query placeholders.
      
      Key insight: Use conditional SQL strings based on hasRepoFilter flag rather than
      building WHERE clauses dynamically. This is safer and more maintainable.
    
    applied_to_tools:
      - search_code: filters by repository (existing pattern)
      - list_recent_files: filters by repository (new in #608)
      - search_dependencies: filters by repository (existing pattern)
    
    pitfalls:
      - what: "Forgetting to validate optional parameter type in type guard"
        instead: "Check both !== undefined AND correct type before using"
        reason: "LLM may pass wrong type; validation prevents crashes"
      - what: "Parameter array length mismatch with SQL placeholders"
        instead: "Use hasFilter flag to control both SQL and params array"
        reason: "Mismatched params cause binding errors"
      - what: "Not documenting optional parameter in tool schema"
        instead: "Add description to inputSchema properties"
        reason: "LLM needs guidance on when to use optional filters"
      - what: "Using hasParameter ? value : undefined in executor"
        instead: "Extract with safe casting: (params.prop as string | undefined)"
        reason: "Type safety and clarity"

  test_mcp_tool:
    when: Testing MCP tool implementations for correctness and edge cases
    approach: |
      1. Create two test files in app/tests/mcp/:
         - <tool-name>.test.ts - Unit tests with validation checks
         - <tool-name>.integration.test.ts - Integration tests with real database
      
      2. Unit test pattern covers parameter validation and error handling
      3. Integration test pattern uses file-based database via KOTADB_PATH
      4. Coverage checklist per tool:
         - Parameter validation (missing, wrong type, invalid values)
         - Empty results and results with data cases
         - Optional parameters (limit, filters)
         - Edge cases (special characters, FTS5 keywords)
    
    timestamp: 2026-01-28
    evidence: commit 8156491 (added 43 tests across 8 MCP tools)
    rationale: |
      Comprehensive MCP tool testing ensures reliability for Claude Code integration.
      Two-tier approach: unit tests verify parameter validation, integration tests
      verify database operations. Using KOTADB_PATH env var allows file-based test
      databases, working around global database singleton pattern.
    
    pitfalls:
      - what: "Using in-memory databases with getGlobalDatabase()"
        instead: "Use KOTADB_PATH env var to point to file-based test database"
        reason: "Global database singleton needs file path for proper isolation"
      - what: "Skipping parameter type validation tests"
        instead: "Test all parameter types and missing required parameters"
        reason: "LLM can pass incorrect types, validation must be robust"

decision_trees:
  endpoint_vs_mcp_tool:
    question: Should this be an HTTP endpoint or MCP tool?
    options:
      - if: Direct user-facing API consumption (REST clients, web apps)
        then: HTTP endpoint in routes.ts
      - if: LLM/Claude Code integration for agentic use
        then: MCP tool in tools.ts
      - if: Both human and LLM consumers needed
        then: Both - HTTP endpoint calls same query function as MCP tool

  auth_placement:
    question: Does this endpoint need authentication?
    options:
      - if: Health check, OpenAPI spec, public info
        then: No auth - check path in middleware skip list
      - if: Any data access or mutation
        then: Yes auth - uses AuthenticatedRequest type
      - note: In local mode, all auth is bypassed (returns local-user context)

  query_vs_mcp:
    question: Where should business logic live?
    options:
      - if: Pure database query (search, list, fetch)
        then: queries.ts - reusable by both routes and MCP
      - if: Complex analysis (impact, validation)
        then: Dedicated module in mcp/ (impact-analysis.ts, spec-validation.ts)
      - if: Indexing workflow
        then: queries.ts - runIndexingWorkflow orchestrates parsers

patterns:
  express_route_pattern:
    structure: |
      app.METHOD("/path", async (req: AuthenticatedRequest, res: Response) => {
          const context = req.authContext!;
          // 1. Extract and validate query params
          const param = req.query.param as string;
          if (!param) {
              addRateLimitHeaders(res, context.rateLimit);
              return res.status(400).json({ error: "Missing param" });
          }
          // 2. Call query function
          try {
              const results = queryFunction(param);
              addRateLimitHeaders(res, context.rateLimit);
              res.json({ results });
          } catch (error) {
              addRateLimitHeaders(res, context.rateLimit);
              res.status(500).json({ error: (error as Error).message });
          }
      });
    notes:
      - AuthenticatedRequest for authenticated routes
      - Request for public routes
      - Always call addRateLimitHeaders before response
      - Return early with status code on validation failure

  mcp_tool_pattern:
    structure: |
      // 1. Tool Definition (tools.ts)
      export const TOOL_NAME: ToolDefinition = {
          name: "tool_name",
          description: "LLM-oriented description",
          inputSchema: {
              type: "object",
              properties: { param: { type: "string" } },
              required: ["param"],
          },
      };

      // 2. Executor Function (tools.ts)
      export async function executeTool(
          params: unknown,
          requestId: string | number,
          userId: string,
      ): Promise<unknown> {
          // Validate params
          if (typeof params !== "object" || params === null) {
              throw new Error("Parameters must be an object");
          }
          const p = params as Record<string, unknown>;
          if (p.param === undefined) {
              throw new Error("Missing required parameter: param");
          }
          // Call query functions
          const result = await queryFunction(p.param as string);
          return { result };
      }

      // 3. Register in server.ts
      // In ListToolsRequestSchema handler:
      return { tools: [..., TOOL_NAME] };
      // In CallToolRequestSchema handler:
      case "tool_name":
          result = await executeTool(toolArgs, "", context.userId);
          break;
    notes:
      - Tool description should guide LLM on when/how to use
      - Input schema properties need descriptions for LLM
      - Executor validates all params before processing
      - Server wraps result in content blocks format

  sqlite_query_pattern:
    structure: |
      // Internal function (testable)
      function queryInternal(
          db: KotaDatabase,
          param: string,
          options: QueryOptions = {},
      ): Result[] {
          const sql = `
              SELECT column1, column2
              FROM table
              WHERE condition = ?
              LIMIT ?
          `;
          const limit = options.limit ?? 20;
          const rows = db.query<RowType>(sql, [param, limit]);
          return rows.map(row => ({ ...row }));
      }

      // Public function (uses global db)
      export function query(param: string, options?: QueryOptions): Result[] {
          return queryInternal(getGlobalDatabase(), param, options);
      }
    notes:
      - KotaDatabase type from @db/sqlite/sqlite-client.js
      - db.query<T>() for SELECT returning rows
      - db.queryOne<T>() for single row or null
      - db.run() for INSERT/UPDATE/DELETE
      - db.transaction(() => {}) for atomic operations
      - db.prepare() for bulk prepared statements

  fts5_search_pattern:
    structure: |
      function escapeFts5Term(term: string): string {
          const escaped = term.replace(/"/g, '""');
          return `"${escaped}"`;
      }

      function searchInternal(db: KotaDatabase, term: string): Result[] {
          const sql = `
              SELECT f.*, snippet(table_fts, 1, '<mark>', '</mark>', '...', 32) AS snippet
              FROM table_fts fts
              JOIN table f ON fts.rowid = f.rowid
              WHERE table_fts MATCH ?
              ORDER BY bm25(table_fts)
              LIMIT ?
          `;
          const escapedTerm = escapeFts5Term(term);
          return db.query<Result>(sql, [escapedTerm, 100]);
      }
    notes:
      - Always escape user input with escapeFts5Term
      - FTS5 MATCH for full-text search
      - bm25() for relevance ranking
      - snippet() for context around matches
    timestamp: 2026-01-28
    evidence: app/src/api/queries.ts lines 257-262, 304

  local_auth_bypass_pattern:
    structure: |
      // app/src/auth/middleware.ts
      const LOCAL_AUTH_CONTEXT: AuthContext = {
          userId: "local-user",
          tier: "team", // Full access in local mode
          keyId: "local-key",
          rateLimitPerHour: Number.MAX_SAFE_INTEGER, // No rate limits
      };

      export async function authenticateRequest(_request: Request): Promise<AuthResult> {
          logger.debug("Local mode: Bypassing authentication");
          return { context: LOCAL_AUTH_CONTEXT };
      }
    notes:
      - All requests in local mode receive full-access context
      - No API key validation or JWT verification
      - Rate limits set to MAX_SAFE_INTEGER (effectively unlimited)
      - requireAdmin() always returns true
    timestamp: 2026-01-28
    evidence: commit d669841 (local-only v2 refactor)
    rationale: |
      Local-only architecture eliminates cloud authentication complexity.
      Simplifies development and dogfooding while maintaining security boundary
      (local access = trusted access).

best_practices:
  routes:
    - Always use addRateLimitHeaders before sending response
    - Extract and validate all query parameters early
    - Use typed AuthenticatedRequest for authenticated routes
    - Return JSON errors with { error: "message" } format

  testing:
    - Create both unit and integration tests for each MCP tool
    - Unit tests: parameter validation, error cases, type checking
    - Integration tests: database operations with seeded fixtures
    - Use KOTADB_PATH env var for file-based test database isolation
    - Clear test data in afterEach to prevent test pollution
    - Aim for 5-8 tests per tool covering all code paths
    - Log errors with createLogger before returning 500

  mcp:
    - Tool descriptions should explain when/why to use the tool
    - Input schema properties need clear descriptions
    - Validate ALL parameters including types and ranges
    - Return structured objects that serialize well to JSON
    - Log tool calls with tool_name and user_id

  queries:
    - Use internal functions with db param for testability
    - Public functions use getGlobalDatabase()
    - Use transactions for multi-statement operations
    - Use prepared statements for bulk inserts
    - Always escape FTS5 search terms with escapeFts5Term()
  openapi:
    - Define Zod schemas for all request/response bodies
    - Include security requirements for authenticated endpoints
    - Use descriptive summaries and longer descriptions
    - Tag endpoints by category (Health, Search, Indexing, etc.)

  logging:
    - Use createLogger({ module: "module-name" })
    - Never use console.log/error/warn
    - Include context (userId, requestId, params) in log objects
    - Use logger.info for operations, logger.error for failures

  security:
    - Validate all file paths with path.resolve() and startsWith(process.cwd())
    - Escape all user input for FTS5 queries
    - Use prepared statements for all SQL queries
    - Never expose raw error stack traces to API responses

known_issues:
  - issue: MCP Accept header requires both application/json AND text/event-stream
    impact: Clients missing Accept header get 406 errors
    resolution: Log warning but continue (SDK validates internally)
    prevention: Document Accept header requirement for MCP clients
    status: ongoing vigilance required

  - issue: OpenAPI spec is cached at startup
    impact: Changes to schemas/paths not reflected until restart
    resolution: Call clearSpecCache() during development
    status: by-design for performance

  - issue: Local mode authentication always succeeds
    impact: No real auth in local development
    resolution: Expected behavior for local-only mode
    status: by-design


  - issue: FTS5 syntax errors from unescaped user input
    impact: "no such column" errors on hyphenated/multi-word/keyword searches
    resolution: Use escapeFts5Term() before all MATCH operations
    prevention: Add FTS5 edge case tests for each search endpoint
    status: resolved (2026-01-28, commit 5af086f)
    timestamp: 2026-01-28

potential_enhancements:
  - enhancement: OpenAPI spec hot reload in development mode
    rationale: Avoid restarts when updating API docs
    effort: low

  - enhancement: Automated MCP tool registration
    rationale: Reduce boilerplate when adding tools
    effort: medium

  - enhancement: Request validation middleware using Zod schemas
    rationale: DRY validation between OpenAPI and routes
    effort: medium

  - enhancement: Response compression middleware
    rationale: Reduce bandwidth for large search results
    effort: low



stability:
  convergence_indicators:
    insight_rate_trend: stable
    contradiction_count: 0
    new_patterns_added_this_cycle: 2
    patterns_updated_this_cycle: 0
    last_reviewed: 2026-01-28
    utility_ratio: 1.0
    notes: |
      Fourth review cycle - Multi-repository filtering support (Issue #608):
      
      New patterns added:
      1. Optional parameter filtering (add_optional_parameter_filters operation)
         - hasRepoFilter conditional SQL pattern for safe filtering
         - Type guard validation for optional parameters
         - Backward compatibility via conditional SQL strings
         - Applied to list_recent_files, search_code, search_dependencies
      
      2. MCP tool testing (test_mcp_tool operation) [from previous cycle]
         - 43 tests across 8 tools (5-8 per tool)
         - Two-tier: unit (validation) + integration (database)
         - KOTADB_PATH isolation for file-based test databases
      
      Previous patterns remain stable:
      - FTS5 search term escaping (5af086f)
      - Local file path validation (efecf9c)
      - Local auth bypass (d669841)
      
      Architecture stability: Very High
      - Local-only v2 patterns fully converged
      - Testing patterns standardized across MCP tools
      - Optional filtering pattern consistent across 3+ tools
      - Zero contradictions across 4 review cycles
      - Insight rate trending stable
      
      Domain maturity: High
      - All core operations documented
      - All 8 MCP tools have comprehensive test coverage
      - Error handling and validation patterns established
      - Multi-repository filtering pattern standardized
      
      Next review: After 10-15 API commits or architectural changes
