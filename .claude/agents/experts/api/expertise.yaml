# KotaDB API Expert Knowledge
# Target: 400-600 lines | Domain: Operational knowledge for API development
# Adapted for KotaDB local-only architecture

overview:
  description: |
    KotaDB API expertise covering Express HTTP server patterns, MCP SDK integration with
    StreamableHTTPServerTransport and StdioServerTransport, OpenAPI specification generation, 
    CLI entry point, and query layer patterns. This expertise enables correct API endpoint, 
    MCP tool, and CLI command implementation within KotaDB's local-only, SQLite-based architecture.
  scope: |
    Covers Express app structure (app/src/api/), route patterns, MCP server and transport
    configuration (stdio and HTTP), MCP tool definitions and executors, OpenAPI spec generation 
    with Zod schemas, CLI entry point (app/src/cli.ts), query layer functions for SQLite, and 
    middleware patterns.

    KOTADB ADAPTATIONS:
    - Local-only mode (no Supabase, no cloud auth)
    - SQLite database via getGlobalDatabase()
    - Authentication bypassed in local mode
    - Synchronous operations (no queue)
    - MCP supports StdioServerTransport (recommended) and StreamableHTTPServerTransport
    - Path aliases (@api/*, @mcp/*, @db/*, @logging/*, etc.)
    - Logging via process.stdout.write (never console.*), forceStderr for stdio mode
    - CLI entry point via bin field in package.json
  rationale: |
    Consistent API implementation enables reliable MCP tool usage and proper endpoint design.
    CLI patterns ensure seamless npm package distribution. Poor structure leads to 
    inconsistent responses, broken tool contracts, and difficult debugging.

core_implementation:
  key_files:
    - path: app/src/cli.ts
      purpose: CLI entry point - argument parsing, server startup, graceful shutdown, stdio transport
      exports: (none - direct execution)
      patterns: shebang, arg parsing, signal handlers, version resolution, stdio mode routing
    - path: app/src/api/routes.ts
      purpose: Express app factory - createExpressApp()
      exports: createExpressApp
    - path: app/src/api/queries.ts
      purpose: SQLite query functions - searchFiles, listRecentFiles, runIndexingWorkflow
      exports: searchFiles, listRecentFiles, ensureRepository, saveIndexedFiles
    - path: app/src/mcp/server.ts
      purpose: MCP Server factory - createMcpServer(), createMcpTransport()
      exports: createMcpServer, createMcpTransport
    - path: app/src/mcp/tools.ts
      purpose: MCP tool definitions and executors
      exports: SEARCH_CODE_TOOL, executeSearchCode, handleToolCall, etc.
    - path: app/src/api/openapi/builder.ts
      purpose: OpenAPI 3.1 spec generator
      exports: buildOpenAPISpec, clearSpecCache
    - path: app/src/logging/logger.ts
      purpose: Structured logging with stderr routing support
      exports: createLogger, Logger, LogContext

key_operations:
  create_cli_entry_point:
    when: Creating npm bin entry point for distributed package
    approach: |
      1. Create app/src/cli.ts with #!/usr/bin/env bun shebang (first line, no BOM)
      2. Import createExpressApp, getEnvironmentConfig, createLogger
      3. Implement getVersion(): Reads package.json at runtime
      4. Implement parseArgs() to handle --help, -h, --version, -v, --port <number>, --stdio
      5. In main(): parse args -> handle --version/--help -> route stdio/HTTP mode
      6. Set up graceful shutdown handlers for SIGTERM and SIGINT (HTTP mode only):
         - Close server and exit(0) on success
         - Force exit(1) after 10-second timeout
      7. Add global error handlers for unhandledRejection and uncaughtException
      8. Export cli.ts in package.json bin field: { "kotadb": "./src/cli.ts" }
    timestamp: 2026-01-28
    evidence: app/src/cli.ts (full implementation)
    rationale: |
      Enables KotaDB distribution as installable npm package via `npx kotadb` or `bunx kotadb`.
      Bun shebang allows direct execution. Graceful shutdown prevents database corruption.
    key_patterns:
      - getVersion() reads package.json at runtime (supports bundled packages)
      - process.argv.slice(2) skips executable and script path
      - Timeout-based forced shutdown (10s) prevents hanging processes (HTTP mode)
      - process.stdout.write for output, process.stderr.write for errors
    pitfalls:
      - what: "Using console.log instead of process.stdout.write"
        instead: "Use process.stdout.write for all CLI output"
        reason: "console.log adds overhead, process.stdout.write is pure"
      - what: "Hardcoding package version in CLI code"
        instead: "Read from package.json at runtime"
        reason: "Must stay in sync with package.json during releases"
      - what: "Missing timeout in shutdown handler"
        instead: "Always include 10-second timeout for forced shutdown"
        reason: "Prevents process hanging if close() doesn't complete"

  implement_mcp_stdio_transport:
    when: Adding stdio transport for MCP server (Claude Code integration)
    approach: |
      1. Import StdioServerTransport from @modelcontextprotocol/sdk/server/stdio.js
      2. Add --stdio flag to CLI option parsing (CliOptions interface)
      3. Create runStdioMode() function:
         - Create logger with forceStderr: true (CRITICAL for JSON-RPC protocol)
         - Create MCP server with createMcpServer(context)
         - Instantiate new StdioServerTransport()
         - Connect server to transport via server.connect(transport)
         - Let transport manage process lifecycle (no explicit shutdown handler)
      4. Update main() to route --stdio flag to runStdioMode()
      5. Add forceStderr support to logger:
         - Add forceStderr?: boolean to LogContext interface
         - Update createLogger() to extract and pass forceStderr flag
         - Update writeLog() to accept forceStderr parameter
         - Route all logs to stderr when forceStderr is true
      6. Update help text to document --stdio flag and stdio configuration
    timestamp: 2026-01-29
    evidence: Issue #49, app/src/cli.ts, app/src/logging/logger.ts
    rationale: |
      Stdio transport eliminates port conflicts (EADDRINUSE on 3000) by using stdin/stdout
      instead of TCP. This is the MCP-recommended pattern for local CLI tools. CRITICAL:
      stdout MUST be reserved for JSON-RPC protocol messages - all logs go to stderr.
    key_patterns:
      - StdioServerTransport from @modelcontextprotocol/sdk/server/stdio.js (v1.25+)
      - forceStderr: true in logger ensures stdout is protocol-only
      - Transport manages process lifecycle (stdin close triggers shutdown)
      - No graceful shutdown handler needed (unlike HTTP mode)
      - Mode selection via CLI flag (--stdio), not environment variable
    pitfalls:
      - what: "Logging to stdout in stdio mode"
        instead: "Use forceStderr: true in createLogger() options"
        reason: "stdout is reserved for JSON-RPC messages, logs corrupt protocol"
      - what: "Adding SIGTERM/SIGINT handlers in stdio mode"
        instead: "Let transport manage lifecycle via stdin close"
        reason: "Transport handles shutdown when Claude Code closes stdin"
      - what: "Using PORT environment variable in stdio mode"
        instead: "Ignore port configuration when --stdio is set"
        reason: "Stdio doesn't use TCP ports, PORT is meaningless"
      - what: "Starting HTTP server when --stdio is set"
        instead: "Route to runStdioMode() and return early"
        reason: "Modes are mutually exclusive - stdio XOR HTTP"
    affected_files: |
      - app/src/cli.ts (CliOptions, parseArgs, runStdioMode, main routing)
      - app/src/logging/logger.ts (LogContext.forceStderr, createLogger, writeLog)
      - README.md (stdio-first documentation)
      - app/tests/cli.test.ts (--stdio flag validation)

  add_express_route:
    when: Adding new HTTP endpoint to the API
    approach: |
      1. Add route inside createExpressApp() in app/src/api/routes.ts
      2. Use AuthenticatedRequest for authenticated routes, Request for public
      3. Always call addRateLimitHeaders(res, context.rateLimit) before response
      4. Extract and validate query params early, return 400 on missing params
      5. Call query functions from @api/queries, handle errors with 500 status
      6. Register in OpenAPI spec via app/src/api/openapi/paths.ts
    examples:
      - GET /search (authenticated, rate-limited)
      - POST /mcp (public, JSON-RPC)
      - GET /health (public, no auth)
    pitfalls:
      - what: "Forgetting addRateLimitHeaders call"
        instead: "Always call it before sending response"
        reason: "Clients expect rate limit headers on all endpoints"

  register_mcp_tool:
    when: Adding new MCP tool for Claude Code integration
    approach: |
      1. Define ToolDefinition in app/src/mcp/tools.ts with name, description, inputSchema
      2. Create executor function: validate params -> call query functions -> return result
      3. Register in createMcpServer: add to ListToolsRequestSchema and CallToolRequestSchema
      4. Validate ALL parameters including types before processing
      5. Return structured objects that serialize well to JSON
    examples:
      - search_code: searches indexed files using FTS5
      - index_repository: runs indexing workflow
      - list_recent_files: lists recently indexed files with optional filtering
    pitfalls:
      - what: "Missing parameter validation"
        instead: "Always type-check all params before using"
        reason: "LLM may pass incorrect parameters"

  add_query_function:
    when: Adding new database query operation
    approach: |
      1. Create internal function with db parameter (for testability)
      2. Create public function using getGlobalDatabase()
      3. Internal functions: db.query<T>(), db.queryOne<T>(), db.run(), db.transaction()
      4. Use db.prepare() for bulk operations
      5. Always escape FTS5 terms with escapeFts5Term() for user input
    kotadb_conventions:
      - Use getGlobalDatabase() from @db/sqlite/index.js for public functions
      - Internal functions take db parameter for testing
      - Transaction wrapper via db.transaction(() => { ... })
      - Prepared statements for bulk inserts

  implement_fts5_search:
    when: Adding or modifying FTS5 full-text search operations
    approach: |
      1. Always escape user input: escapeFts5Term(term) wraps in double quotes
      2. Use FTS5 MATCH operator with escaped terms
      3. Use bm25() for relevance ranking and snippet() for context
      4. Test edge cases: hyphenated terms, multi-word phrases, FTS5 keywords, quotes
    rationale: |
      Prevents SQL errors on multi-word phrases, hyphens, and FTS5 keywords.
      Double-quote escaping forces exact phrase matching and treats input as literal.
    pitfalls:
      - what: "Passing raw user input to MATCH"
        instead: "Always use escapeFts5Term() first"
        reason: "Unescaped input breaks FTS5 query parsing"

  validate_local_file_paths:
    when: Accepting file paths in local mode API operations
    approach: |
      1. Use path.resolve(localPath) to convert to absolute path
      2. Verify path.startsWith(process.cwd()) to prevent traversal attacks
      3. Check fs.existsSync(resolvedPath) if needed
    rationale: |
      Local mode indexing accepts user-provided paths. Without validation,
      "../../../etc/passwd" could expose sensitive files. Restrict all paths 
      to within process.cwd() workspace directory.

  add_optional_parameter_filters:
    when: Adding optional filtering parameters to query functions and MCP tools
    approach: |
      1. Create internal function with optional parameter (e.g., repositoryId?: string)
      2. Use hasFilter flag to control both SQL string AND params array
      3. Type guard in executor: validate optional param type before using
      4. Extract with safe casting: (params.prop as string | undefined)
      5. Document optional parameter in tool inputSchema with description
    timestamp: 2026-01-28
    evidence: Issue #608 (repository filtering for list_recent_files)
    rationale: |
      Enables multi-repository support without breaking backward compatibility.
      hasRepoFilter conditional pattern avoids dynamic SQL and ensures parameter 
      arrays match query placeholders.
    pitfalls:
      - what: "Parameter array length mismatch with SQL placeholders"
        instead: "Use hasFilter flag to control both SQL and params"
        reason: "Mismatched params cause binding errors"

  test_mcp_tool:
    when: Testing MCP tool implementations for correctness and edge cases
    approach: |
      1. Create <tool-name>.test.ts (unit) and <tool-name>.integration.test.ts (integration)
      2. Unit tests: parameter validation, error cases, type checking
      3. Integration tests: database operations using KOTADB_PATH env var
      4. Cover: parameter validation, empty/populated results, optional params, edge cases
    timestamp: 2026-01-28
    evidence: commit 8156491 (43 tests across 8 MCP tools)
    rationale: |
      Two-tier approach ensures parameter validation and database operations work.
      KOTADB_PATH allows file-based test databases, working around global singleton.
    pitfalls:
      - what: "Using in-memory databases with getGlobalDatabase()"
        instead: "Use KOTADB_PATH env var for file-based test database"
        reason: "Global singleton needs file path for proper isolation"


  implement_tool_tier_filtering:
    when: Adding CLI-based tool filtering to support different MCP tool subsets (core, memory, expertise)
    approach: |
      1. Define ToolTier enum for categorization: "core" | "sync" | "memory" | "expertise"
      2. Add tier property to ToolDefinition interface in app/src/mcp/tools.ts
      3. Tag each tool definition with appropriate tier:
         - core: Essential code intelligence (search, index, dependencies, impact, context)
         - sync: Git sync tools (kota_sync_export, kota_sync_import)
         - memory: Memory layer (decisions, failures, patterns, insights)
         - expertise: Dynamic expertise validation and pattern extraction
      4. Define ToolsetTier for user-facing selection: "default" | "core" | "memory" | "full"
      5. Create filterToolsByTier() function with tier mapping logic:
         - core: 6 tools (core tier only)
         - default: 8 tools (core + sync tiers)
         - memory: 14 tools (core + sync + memory tiers)
         - full: all tools (all tiers)
      6. Add --toolset CLI flag to parseArgs() with validation
      7. Extract CLI parsing to separate module (app/src/cli/args.ts) for testability
      8. Pass toolset via McpServerContext.toolset to server
      9. Filter tools in ListToolsRequestSchema handler using context.toolset
      10. Create comprehensive tests covering tier hierarchy and filtering
    timestamp: 2026-02-03
    evidence: |
      Uncommitted changes in git diff:
      - app/src/cli.ts (--toolset flag, runStdioMode parameter)
      - app/src/cli/args.ts (extracted parsing, ToolsetTier type guard)
      - app/src/mcp/server.ts (McpServerContext.toolset, filtered tool listing)
      - app/src/mcp/tools.ts (ToolTier property, filterToolsByTier function)
      - app/tests/cli/toolset.test.ts (CLI parsing tests)
      - app/tests/mcp/toolset-filtering.test.ts (tier filtering tests)
      - README.md (toolset tier documentation table)
    rationale: |
      Tool proliferation creates cognitive overload for LLMs and reduces token efficiency.
      Different use cases need different tool sets - Claude Code users may only need core tools,
      while agentic workflows benefit from memory layer. Tiered architecture allows gradual
      adoption: start with core (6 tools), expand to memory (14 tools), enable all for experts.
      CLI-based selection is more flexible than compile-time configuration.
    key_patterns:
      - Separate ToolTier (internal categorization) from ToolsetTier (user-facing selection)
      - Hierarchical tier design: each tier includes previous (core ⊂ default ⊂ memory ⊂ full)
      - Extract CLI parsing to separate module for testability (avoid mocking main())
      - Type guards for runtime validation (isValidToolsetTier)
      - Filter at server initialization (ListToolsRequestSchema) not per tool call
      - Comprehensive tests verify tier hierarchy and exact tool counts
    pitfalls:
      - what: "Filtering tools in CallToolRequestSchema handler"
        instead: "Filter in ListToolsRequestSchema only"
        reason: "Client should only see available tools, attempting unavailable tool is client error"
      - what: "Using environment variables for tier selection"
        instead: "Use CLI flag (--toolset) for explicit control"
        reason: "CLI flags are more visible and don't persist across sessions"
      - what: "Hardcoding tier logic in each executor"
        instead: "Single filterToolsByTier() function based on tier property"
        reason: "Centralized logic prevents tier drift"
      - what: "Breaking tier hierarchy (default doesn't include core)"
        instead: "Test tier hierarchy with set containment checks"
        reason: "Unexpected behavior if higher tiers exclude lower tier tools"
    affected_files: |
      - app/src/cli.ts (ToolsetTier import, parseArgs, runStdioMode signature)
      - app/src/cli/args.ts (new file - extracted CLI parsing logic)
      - app/src/mcp/server.ts (McpServerContext interface, tool filtering)
      - app/src/mcp/tools.ts (ToolTier type, tier property, filterToolsByTier)
      - app/tests/cli/toolset.test.ts (new file - CLI parsing tests)
      - app/tests/mcp/toolset-filtering.test.ts (new file - tier filtering tests)

  resolve_flexible_repository_identifiers:
    when: Adding support for repository identification by full_name OR UUID in MCP tools
    approach: |
      1. Create resolveRepositoryIdentifierWithError() helper in queries module
      2. Accept repository parameter as string (UUID or owner/repo format)
      3. Try UUID resolution first: SELECT * FROM repositories WHERE id = ?
      4. Fall back to full_name resolution: SELECT * FROM repositories WHERE full_name = ?
      5. Return { id: string } on success or { error: string } on failure
      6. Use in tool executors BEFORE calling query functions:
         - Extract optional repository parameter
         - Call resolveRepositoryIdentifierWithError if present
         - Return early with error message if resolution fails
         - Pass resolved UUID to query functions
      7. Update query functions to accept repositoryId (UUID) not repository (any format)
    timestamp: 2026-02-03
    evidence: Commit 9adc86f "fix(mcp): resolve full_name to UUID in list_recent_files #137 (#141)"
    rationale: |
      User experience improvement: developers think in terms of "owner/repo" names, not UUIDs.
      Internal consistency: query functions should work with stable IDs (UUIDs), not user-facing names.
      Separation of concerns: resolution logic belongs in executor layer, not query layer.
    key_patterns:
      - Resolution at tool executor boundary (before query calls)
      - Query functions accept normalized IDs (UUID) only
      - Try-fallback pattern: UUID first, then full_name
      - Return error object vs throwing (enables graceful tool failure messages)
      - Early return pattern: resolve -> check error -> proceed or return
    pitfalls:
      - what: "Putting resolution logic in query functions"
        instead: "Resolve in executor, pass UUID to query"
        reason: "Query functions should work with normalized IDs only"
      - what: "Throwing errors on invalid repository"
        instead: "Return { error: string } for graceful handling"
        reason: "MCP tools should return structured errors, not throw"
      - what: "Only supporting UUID format"
        instead: "Support both UUID and full_name (owner/repo)"
        reason: "User experience - developers think in repo names"
    affected_files: |
      - app/src/api/queries.ts (resolveRepositoryIdentifierWithError helper)
      - app/src/mcp/tools.ts (executeListRecentFiles resolver usage)

  extract_cli_parsing_for_testability:
    when: Need to test CLI argument parsing without invoking main() or mocking process.exit
    approach: |
      1. Create app/src/cli/args.ts module for testable parsing logic
      2. Define CliOptions interface with all CLI flags
      3. Extract parseArgs(args: string[]): CliOptions function
      4. Extract validation helpers (isValidToolsetTier, etc.)
      5. Keep error handling in parseArgs (process.stderr.write + process.exit)
      6. Import and use in main CLI entry point (app/src/cli.ts)
      7. Write unit tests against exported parseArgs function
      8. Test error paths by expecting process.exit() calls
    timestamp: 2026-02-03
    evidence: New file app/src/cli/args.ts + app/tests/cli/toolset.test.ts
    rationale: |
      Testing main() is difficult: requires mocking process.exit, process.argv, stdout/stderr.
      Extracting parseArgs enables direct unit testing with controlled inputs.
      Follows antimocking philosophy: test real parsing logic, not mocks.
    key_patterns:
      - Pure parsing function: string[] -> CliOptions
      - Validation helpers return booleans (type guards)
      - Error messages via process.stderr.write (not thrown exceptions)
      - process.exit(1) for invalid input (expected behavior, testable via expect)
      - CliOptions interface defines all flags with defaults
    pitfalls:
      - what: "Throwing exceptions on invalid input"
        instead: "Write to stderr and call process.exit(1)"
        reason: "CLI tools should exit with status codes, not throw"
      - what: "Testing main() directly"
        instead: "Extract parseArgs and test that"
        reason: "Avoids complex mocking of process global"

  configure_npm_package_distribution:
    when: Publishing TypeScript package with path aliases for direct execution (Bun/ts-node)
    approach: |
      1. Include tsconfig.json in package.json files array (required for alias resolution)
      2. Relocate shared dependencies from external monorepo siblings into package root
      3. Update path aliases in tsconfig.json to reference internal paths
      4. Add all aliased directories to files array (e.g., "shared/**/*.ts")
      5. Add all aliased directories to tsconfig.json include array
      6. Update monorepo workspace configuration to remove relocated packages
      7. Update CI workflows to remove separate type-checking steps for relocated code
      8. Test locally: npm pack -> bunx <tarball> to verify module resolution
    timestamp: 2026-01-29
    evidence: Issue #39, pending changes for v2.0.1
    rationale: |
      When Bun executes TypeScript directly (not transpiled), it uses tsconfig.json to
      resolve path aliases at runtime. Without this file in the published package, imports
      like @api/routes fail with "Cannot find module" errors. External path aliases
      (../shared/*) break because npm only publishes files within package directory.
    key_patterns:
      - tsconfig.json MUST be in files array for runtime alias resolution
      - Path aliases must reference internal paths (./shared/*, not ../shared/*)
      - All aliased directories must be included in both files array AND include array
      - Test with npm pack + bunx before publishing to catch resolution issues
    pitfalls:
      - what: "Excluding tsconfig.json from published package"
        instead: "Always include tsconfig.json in files array"
        reason: "Bun needs it to resolve path aliases at runtime"
      - what: "Path aliases pointing outside package root (../shared/*)"
        instead: "Relocate dependencies into package or reference internally (./shared/*)"
        reason: "npm only publishes files within package directory"
      - what: "Adding to files array but not include array"
        instead: "Add aliased directories to BOTH files and include arrays"
        reason: "Type-checking needs include, runtime needs files"
      - what: "Publishing without local testing"
        instead: "Always test with npm pack + bunx <tarball> first"
        reason: "Catches module resolution issues before public publish"
    affected_files: |
      When restructuring for npm distribution:
      - app/package.json (files array, version bump)
      - app/tsconfig.json (paths, include array)
      - package.json (workspaces array if monorepo)
      - .github/workflows/npm-publish.yml (CI adjustments)

  maintain_openapi_spec:
    when: Updating OpenAPI specification after architectural changes or feature removals
    approach: |
      1. Audit OpenAPI spec for spec-implementation drift:
         - Check registered paths in paths.ts against actual routes in routes.ts
         - Verify all referenced schemas exist and are used
         - Confirm server definitions match deployment architecture
      2. Remove unused/obsolete content:
         - Delete schemas for removed features (check imports in paths.ts)
         - Remove server definitions for non-existent environments
         - Remove endpoint tags that don't match any paths
         - Clean up auth scheme descriptions (remove cloud provider references in local mode)
      3. Update documentation strings in builder.ts:
         - Reflect current architecture (local-only vs cloud)
         - Document MCP tools separately from HTTP endpoints
         - Update rate limit header documentation to match implementation
      4. Synchronize tests with spec changes:
         - Update openapi-generation.test.ts assertions
         - Verify all endpoint examples are valid
      5. Test spec generation:
         - Run tests: cd app && bun test openapi
         - Verify spec serves correctly: GET /openapi.json
         - Check for validation errors in OpenAPI validators
    timestamp: 2026-02-02
    evidence: Issues #74, #83 (commits 7195834, 52510fb)
    rationale: |
      OpenAPI specs accumulate drift as features are added/removed. Undocumented endpoints
      mislead API consumers. Obsolete schemas increase cognitive load. Regular hygiene
      maintains spec accuracy and prevents confusion between documented vs implemented APIs.
      Critical for local-only transitions where cloud references must be removed.
    key_patterns:
      - Implement routes first, then add to OpenAPI (not spec-first)
      - Remove schemas when last endpoint using them is removed
      - Server definitions must match actual deployment architecture
      - Separate MCP tool documentation from HTTP endpoint documentation
      - Test spec generation after structural changes
    pitfalls:
      - what: "Adding OpenAPI paths without implementing routes"
        instead: "Implement route in routes.ts first, then register in paths.ts"
        reason: "Prevents documenting non-existent endpoints (Issue #74)"
      - what: "Leaving cloud-only schemas in local-only mode"
        instead: "Remove Jobs, Projects, API Keys schemas when features removed"
        reason: "Dead schemas confuse developers and bloat spec"
      - what: "Keeping production/staging server definitions in local-only mode"
        instead: "Remove all non-localhost server definitions"
        reason: "Misleads users about deployment options"
      - what: "Updating paths.ts without checking schema imports"
        instead: "Remove unused schema imports and definitions"
        reason: "Orphaned schemas increase maintenance burden"
    affected_files: |
      - app/src/api/openapi/builder.ts (server defs, info, descriptions)
      - app/src/api/openapi/paths.ts (endpoint registrations)
      - app/src/api/openapi/schemas.ts (request/response schemas)
      - app/tests/api/openapi-generation.test.ts (spec validation)

patterns:
  cli_entry_point_pattern:
    structure: |
      See create_cli_entry_point operation for full implementation.
      Key: Shebang, parseArgs(), getVersion(), shutdown handlers
    timestamp: 2026-01-29
    evidence: app/src/cli.ts

  mcp_stdio_mode_pattern:
    structure: |
      // app/src/cli.ts (stdio transport mode)
      import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
      import { createMcpServer, type McpServerContext } from "@mcp/server";
      
      async function runStdioMode(): Promise<void> {
        // CRITICAL: All logs must go to stderr in stdio mode
        const logger = createLogger({
          module: "mcp-stdio",
          forceStderr: true,  // stdout reserved for JSON-RPC
        });
      
        logger.info("KotaDB MCP server starting in stdio mode", {
          version: getVersion(),
        });
      
        // Create MCP server (same as HTTP mode)
        const context: McpServerContext = {
          userId: "local",  // Local-only mode
        };
        const server = createMcpServer(context);
      
        // Create and connect stdio transport
        const transport = new StdioServerTransport();
        await server.connect(transport);
      
        logger.info("KotaDB MCP server connected via stdio");
      
        // Process stays alive until stdin closes (Claude Code manages lifecycle)
      }
      
      async function main(): Promise<void> {
        const options = parseArgs(process.argv.slice(2));
        
        // Route to stdio mode
        if (options.stdio) {
          await runStdioMode();
          return;  // runStdioMode() keeps process alive
        }
        
        // Otherwise start HTTP server (existing code)
        // ...
      }
    notes:
      - StdioServerTransport requires @modelcontextprotocol/sdk v1.25+
      - forceStderr: true is CRITICAL - stdout is reserved for JSON-RPC protocol
      - No graceful shutdown handler needed - transport manages lifecycle
      - Process terminates when Claude Code closes stdin
      - Same MCP server works with both stdio and HTTP transports
    timestamp: 2026-01-29
    evidence: app/src/cli.ts (runStdioMode implementation)

  logger_stderr_routing_pattern:
    structure: |
      See implement_mcp_stdio_transport operation for details.
      Key: LogContext.forceStderr, writeLog routing
    timestamp: 2026-01-29
    evidence: app/src/logging/logger.ts

  express_route_pattern:
    structure: |
      See add_express_route operation.
      Key: AuthenticatedRequest, addRateLimitHeaders, early validation

  mcp_tool_pattern:
    structure: |
      See register_mcp_tool operation for full pattern.
      Key: ToolDefinition with inputSchema, executor with parameter validation

  sqlite_query_pattern:
    structure: |
      See add_query_function operation.
      Key: Internal function with db param, public uses getGlobalDatabase()

  fts5_search_pattern:
    structure: |
      See implement_fts5_search operation.
      Key: escapeFts5Term() before MATCH, bm25() for ranking, snippet() for context

  npm_package_files_pattern:
    structure: |
      See configure_npm_package_distribution operation.
      Key: tsconfig.json in files array, path aliases, testing with npm pack
    timestamp: 2026-01-29
    evidence: Issue #39

  tool_tier_filtering_pattern:
    structure: |
      // app/src/mcp/tools.ts (tool tier categorization and filtering)
      export type ToolTier = "core" | "sync" | "memory" | "expertise";
      export type ToolsetTier = "default" | "core" | "memory" | "full";
      
      export interface ToolDefinition {
        name: string;
        tier: ToolTier;  // NEW: categorize by feature tier
        description: string;
        inputSchema: { /* ... */ };
      }
      
      export const SEARCH_CODE_TOOL: ToolDefinition = {
        tier: "core",  // Essential code intelligence
        name: "search_code",
        description: "Search indexed code files...",
        inputSchema: { /* ... */ },
      };
      
      export function filterToolsByTier(tier: ToolsetTier): ToolDefinition[] {
        const allTools = getToolDefinitions();
        switch (tier) {
          case "core":
            return allTools.filter((t) => t.tier === "core");
          case "default":
            return allTools.filter((t) => t.tier === "core" || t.tier === "sync");
          case "memory":
            return allTools.filter((t) => 
              t.tier === "core" || t.tier === "sync" || t.tier === "memory"
            );
          case "full":
            return allTools;
        }
      }
      
      // app/src/mcp/server.ts (context-aware tool listing)
      export interface McpServerContext {
        userId: string;
        toolset?: ToolsetTier;  // NEW: optional tier selection
      }
      
      server.setRequestHandler(ListToolsRequestSchema, async () => {
        const tier = context.toolset || "default";
        const filteredTools = filterToolsByTier(tier);
        return { tools: filteredTools };
      });
      
      // app/src/cli/args.ts (testable CLI parsing)
      export type ToolsetTier = "default" | "core" | "memory" | "full";
      export interface CliOptions {
        port: number;
        stdio: boolean;
        toolset: ToolsetTier;  // NEW: CLI-selectable tier
      }
      
      export function isValidToolsetTier(value: string): value is ToolsetTier {
        return ["default", "core", "memory", "full"].includes(value);
      }
      
      export function parseArgs(args: string[]): CliOptions {
        const options: CliOptions = { 
          port: 3000, 
          stdio: false, 
          toolset: "default" 
        };
        
        for (let i = 0; i < args.length; i++) {
          if (args[i] === "--toolset") {
            const tierStr = args[++i];
            if (!isValidToolsetTier(tierStr)) {
              process.stderr.write(`Invalid toolset: ${tierStr}\n`);
              process.exit(1);
            }
            options.toolset = tierStr;
          }
        }
        return options;
      }
    notes:
      - ToolTier (internal): Categorizes tools by feature domain
      - ToolsetTier (user-facing): CLI flag values for tier selection
      - Hierarchical design: core ⊂ default ⊂ memory ⊂ full
      - Filter at ListToolsRequestSchema (not per tool call)
      - Extract CLI parsing to separate module for testability
      - Type guards enable runtime validation of CLI input
    timestamp: 2026-02-03
    evidence: Uncommitted changes across app/src/cli/, app/src/mcp/
    
  repository_identifier_resolution_pattern:
    structure: |
      // app/src/api/queries.ts (flexible identifier resolution)
      export function resolveRepositoryIdentifierWithError(
        identifier: string
      ): { id: string } | { error: string } {
        const db = getGlobalDatabase();
        
        // Try UUID first
        const byId = db.queryOne<{ id: string }>(
          `SELECT id FROM repositories WHERE id = ?`,
          [identifier]
        );
        if (byId) return { id: byId.id };
        
        // Fall back to full_name (owner/repo)
        const byFullName = db.queryOne<{ id: string }>(
          `SELECT id FROM repositories WHERE full_name = ?`,
          [identifier]
        );
        if (byFullName) return { id: byFullName.id };
        
        return { error: `Repository not found: ${identifier}` };
      }
      
      // app/src/mcp/tools.ts (executor-level resolution)
      export async function executeListRecentFiles(
        params: unknown,
        requestId: string | number,
        userId: string
      ): Promise<unknown> {
        // Extract optional repository parameter
        const repository = (params as Record<string, unknown>).repository;
        
        // Resolve to UUID if provided
        let repositoryId: string | undefined;
        if (repository && typeof repository === "string") {
          const result = resolveRepositoryIdentifierWithError(repository);
          if ("error" in result) {
            return { results: [], message: result.error };
          }
          repositoryId = result.id;
        }
        
        // Call query function with normalized ID
        const files = listRecentFiles(limit, repositoryId);
        return { results: files };
      }
    notes:
      - Resolve at executor boundary (before query calls)
      - Query functions accept UUID only (normalized IDs)
      - Try-fallback pattern: UUID first, then full_name
      - Return error object vs throwing (graceful MCP tool failures)
      - Early return pattern: resolve -> check error -> proceed
      - User experience: developers think in repo names, not UUIDs
    timestamp: 2026-02-03
    evidence: Commit 9adc86f (list_recent_files full_name support)

  cli_parsing_extraction_pattern:
    structure: |
      // app/src/cli/args.ts (extracted for testability)
      export interface CliOptions {
        port: number;
        help: boolean;
        version: boolean;
        stdio: boolean;
        toolset: ToolsetTier;
      }
      
      export function isValidToolsetTier(value: string): value is ToolsetTier {
        return ["default", "core", "memory", "full"].includes(value);
      }
      
      export function parseArgs(args: string[]): CliOptions {
        const options: CliOptions = {
          port: Number(process.env.PORT ?? 3000),
          help: false,
          version: false,
          stdio: false,
          toolset: "default",
        };
        
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg === "--toolset") {
            const tierStr = args[++i];
            if (!tierStr || !isValidToolsetTier(tierStr)) {
              process.stderr.write("Error: Invalid toolset\n");
              process.exit(1);
            }
            options.toolset = tierStr;
          }
          // ... other flags
        }
        return options;
      }
      
      // app/tests/cli/toolset.test.ts (direct testing)
      test("parseArgs correctly parses --toolset core", () => {
        const options = parseArgs(["--toolset", "core"]);
        expect(options.toolset).toBe("core");
      });
      
      test("parseArgs defaults to 'default' when no --toolset", () => {
        const options = parseArgs([]);
        expect(options.toolset).toBe("default");
      });
    notes:
      - Extract pure parsing logic: string[] -> CliOptions
      - Keep validation in parseArgs (process.exit on error)
      - Export type guards for reusability
      - CliOptions defines all flags with defaults
      - Test directly without mocking process.argv
      - Follows antimocking: test real logic, not mocks
    timestamp: 2026-02-03
    evidence: app/src/cli/args.ts, app/tests/cli/toolset.test.ts

          "tsconfig.json",        // Required for path alias resolution
          "shared/**/*.ts"        // Include all aliased dependencies
        ]
      }
      
      // app/tsconfig.json
      {
        "compilerOptions": {
          "baseUrl": ".",
          "paths": {
            "@api/*": ["src/api/*"],
            "@shared/*": ["./shared/*"]  // Internal reference, not ../shared/*
          }
        },
        "include": [
          "src/**/*.ts",
          "tests/**/*.ts",
          "shared/**/*.ts"  // Must include aliased directories
        ]
      }
    notes:
      - tsconfig.json in files array enables runtime path alias resolution
      - All path aliases must reference internal paths relative to package root
      - Aliased directories must appear in BOTH files and include arrays
      - Test with npm pack + bunx before publishing
      - Alternative: transpile to JS with resolved imports (different trade-offs)
    timestamp: 2026-01-29
    evidence: Issue #39 fix for v2.0.1

best_practices:
  cli: |
    - Include #!/usr/bin/env bun shebang on first line (no BOM)
    - Use process.stdout.write for output, process.stderr.write for errors
    - Read version from package.json at runtime, not hardcoded
    - Register BOTH SIGTERM and SIGINT handlers (HTTP mode only)
    - Include 10-second forced shutdown timeout (HTTP mode only)
  
  routes: |
    - Always addRateLimitHeaders before response
    - Extract and validate params early
    - Use AuthenticatedRequest for authenticated routes
    - Return JSON errors: { error: "message" }
  
  mcp: |
    - Tool descriptions explain when/why to use
    - Validate ALL parameters including types
    - Return structured objects that serialize to JSON
    - Log tool calls with tool_name and user_id
  
  mcp_transports: |
    - Use stdio transport for Claude Code integration (recommended)
    - Use HTTP transport for multi-client scenarios or remote access
    - CRITICAL: In stdio mode, ALL logs must go to stderr (forceStderr: true)
    - Stdio: Transport manages lifecycle, no shutdown handlers needed
    - HTTP: Requires graceful shutdown handlers for SIGTERM/SIGINT
    - Mode selection via CLI flag (--stdio), not environment variable
    - Document both transports in README with stdio-first recommendation
  
  queries: |
    - Internal functions take db param (testable)
    - Public functions use getGlobalDatabase()
    - Always escape FTS5 terms with escapeFts5Term()
    - Use transactions for multi-statement operations
  
  testing: |
    - Unit tests: parameter validation, error cases
    - Integration tests: database operations with KOTADB_PATH
    - Aim for 5-8 tests per tool covering all paths
    - Clear test data in afterEach
  
  npm_distribution: |
    - Include tsconfig.json in files array for path alias resolution
    - Relocate external dependencies into package root (./shared/*, not ../shared/*)
    - Add aliased directories to BOTH files and include arrays
    - Test with npm pack + bunx <tarball> before publishing
    - Update CI workflows when restructuring monorepo packages
  
  openapi: |
    - Implement routes first, document in OpenAPI second
    - Remove schemas when last using endpoint is removed
    - Keep server definitions synchronized with deployment architecture
    - Separate MCP tool docs from HTTP endpoint docs
    - Run tests after spec changes (bun test openapi)
    - Audit for spec-implementation drift during major refactors

known_issues:
  - issue: OpenAPI spec cached at startup
    impact: Changes not reflected until restart
    status: by-design for performance
    resolution: Call clearSpecCache() during development

  - issue: FTS5 syntax errors from unescaped input
    impact: '"no such column" errors on hyphenated/multi-word searches'
    status: resolved (2026-01-28, commit 5af086f)
    resolution: Always use escapeFts5Term() before MATCH

  - issue: npm package missing tsconfig.json and shared types
    impact: bunx kotadb fails with "Cannot find module @api/routes" 
    status: resolved (2026-01-29, Issue #39)
    resolution: Include tsconfig.json and shared/**/*.ts in files array, relocate shared/ into app/

  - issue: MCP server port conflicts (EADDRINUSE on 3000)
    impact: Cannot start multiple instances or when port occupied
    status: resolved (2026-01-29, Issue #49)
    resolution: Stdio transport eliminates port conflicts (uses stdin/stdout, not TCP)

  - issue: OpenAPI spec documenting unimplemented POST /index endpoint
    impact: Misleading API documentation, confusion about indexing methods
    status: resolved (2026-02-02, Issue #74)
    resolution: Remove endpoint from OpenAPI spec, clarify MCP-only indexing

  - issue: Cloud-only schemas in local-only OpenAPI spec
    impact: 303 lines of unused schemas (Jobs, Projects, API Keys) causing confusion
    status: resolved (2026-02-02, Issue #83)
    resolution: Remove cloud-only schemas, update server definitions, add MCP tools section

stability:
  convergence_indicators:
    insight_rate_trend: stable
    contradiction_count: 0
    new_patterns_added_this_cycle: 3
    patterns_updated_this_cycle: 0
    new_operations_added_this_cycle: 3
    last_reviewed: 2026-02-03
    utility_ratio: 1.0
    notes: |
      Ninth review cycle - Tool tier filtering and repository identifier resolution:
      
      New operations (3):
      1. implement_tool_tier_filtering - CLI-based MCP tool filtering with tiered subsets
      2. resolve_flexible_repository_identifiers - UUID + full_name resolution pattern
      3. extract_cli_parsing_for_testability - Separate parsing logic for unit testing
      
      New patterns (3):
      1. tool_tier_filtering_pattern - ToolTier vs ToolsetTier separation, hierarchical design
      2. repository_identifier_resolution_pattern - Executor-level resolution, try-fallback
      3. cli_parsing_extraction_pattern - Testable parseArgs without mocking process
      
      Architectural significance:
      - Tool tier system addresses LLM cognitive overload (20 -> 6-14 tools selectable)
      - Hierarchical tier design enables gradual adoption path
      - Repository identifier flexibility improves developer experience
      - CLI extraction pattern enables antimocking test philosophy
      
      Previously stable patterns (all remain valid):
      - CLI entry point (Issue #19)
      - MCP stdio transport (Issue #49)
      - Optional parameter filtering (Issue #608)
      - MCP tool testing patterns
      - FTS5 search term escaping
      - Local file path validation
      - Local auth bypass
      - npm package distribution
      - OpenAPI maintenance
      
      Architecture stability: High
      - Zero contradictions across 9 cycles
      - New patterns extend (not replace) existing architecture
      - Tier system is additive change - existing tools unchanged
      - Repository resolution improves ergonomics without breaking changes
      
      Size governance:
      - Current size: 955 lines (after additions and consolidation)
      - Exceeded 800-line warning threshold, applied pruning to stay under 1000
      - Pruned redundant pattern details already covered in operations
      - Condensed: cli_entry_point, logger_stderr, express_route, mcp_tool, sqlite_query, fts5_search patterns
      - All new content is high-utility architectural patterns (tool tiers, repo resolution)
      - Recommend monitoring: next pruning cycle if reaches 1000 lines
      
      Next review: After 10-15 API commits or new architectural patterns
