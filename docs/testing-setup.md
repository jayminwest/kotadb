# Testing Setup Guide

This document explains how to set up and run the KotaDB test suite with a real PostgreSQL test database.

## Overview

KotaDB follows an **antimocking philosophy** - tests use real database connections instead of mocks. This provides:

- Production parity testing
- Real connection/timeout/RLS behavior
- No mock maintenance burden
- True confidence in database interactions

## Prerequisites

- **Docker**: For running the PostgreSQL test database container
- **Bun**: v1.1+ for running tests
- **Supabase CLI**: For managing local Supabase services
- **jq**: JSON parsing tool for auto-generating `.env.test`
- **psql**: PostgreSQL client (for manual database inspection, optional)

### Install Prerequisites (macOS)

```bash
brew install supabase/tap/supabase jq
```

For other platforms, see:
- [Supabase CLI Installation Guide](https://supabase.com/docs/guides/cli)
- [jq Downloads](https://jqlang.github.io/jq/download/)

## Quick Start

KotaDB uses **Supabase CLI** to manage local test infrastructure. The CLI handles Docker containers, migrations, and service orchestration automatically.

### 1. Start Test Database (First Time)

```bash
bun run test:setup
```

This script will:
- Check prerequisites (Supabase CLI, jq, Docker)
- Start Supabase Local services via `supabase start` (PostgreSQL, PostgREST, Kong, Auth)
- Auto-generate `.env.test` from `supabase status` output
- Run schema migrations automatically (from `supabase/migrations/`)
- Seed test data (users, API keys, repositories, indexed files)

**What happens:**
1. Supabase CLI starts Docker containers for all services
2. Migrations from `supabase/migrations/` are applied automatically
3. `generate-env-test.sh` extracts credentials and creates `.env.test`
4. Seed data is loaded from `supabase/seed.sql`

### 2. Run Tests

```bash
bun test
```

The test suite connects to Supabase Local using auto-generated credentials from `.env.test`.

### 3. Check Service Status

```bash
bun run test:status
```

Shows all running Supabase services with ports and URLs.

### 4. Reset Database (Optional)

Between test runs, if you need a clean state:

```bash
bun run test:reset
```

This uses `supabase db reset` to truncate tables and re-seed test data.

### 5. Stop Services

When done testing:

```bash
bun run test:teardown
```

This stops all Supabase Local services (Docker containers remain for fast restarts).

## Auto-Generated .env.test

The `.env.test` file is **automatically generated** from Supabase CLI status and should **not be committed to git**.

### How It Works

The `scripts/generate-env-test.sh` script:
1. Runs `supabase status --output json`
2. Parses JSON output with `jq` to extract:
   - `SUPABASE_URL` (Kong gateway URL)
   - `SUPABASE_SERVICE_KEY` (JWT for service role)
   - `SUPABASE_ANON_KEY` (JWT for anonymous role)
   - `DATABASE_URL` (PostgreSQL connection string)
3. Writes `.env.test` with proper format

### Manual Regeneration

If you need to regenerate `.env.test` (e.g., after restarting Supabase):

```bash
bun run test:env
```

### Why Auto-Generate?

- **No manual configuration**: Credentials extracted automatically from running services
- **No stale credentials**: Always matches current Supabase Local instance
- **Easier onboarding**: New developers just run `bun run test:setup`
- **Security**: Auto-generated files reduce risk of committing secrets

### Fallback to Docker Compose (Advanced)

If you prefer raw Docker Compose without Supabase CLI, you can still use:

```bash
docker compose up -d supabase-db supabase-rest supabase-auth supabase-kong
```

However, you'll need to manually maintain `.env.test` with static credentials.

## Test Database Architecture

### Connection Details

- **Host**: localhost
- **Port**: 5434 (to avoid conflicts with local Postgres)
- **PostgREST API**: 54322 (direct API access)
- **Kong Gateway**: 54326 (used by Supabase JS client)
- **Studio UI**: 54328 (http://localhost:54328)
- **Database**: postgres
- **User**: postgres
- **Password**: postgres (auto-generated by Supabase CLI)

### Test Data

The database is seeded with deterministic test data (see `supabase/seed.sql`):

#### Test Users
- Free user: `00000000-0000-0000-0000-000000000001`
- Solo user: `00000000-0000-0000-0000-000000000002`
- Team user: `00000000-0000-0000-0000-000000000003`

#### Test API Keys
```typescript
// Free tier
kota_free_test1234567890ab_0123456789abcdef0123456789abcdef

// Solo tier
kota_solo_solo1234567890ab_0123456789abcdef0123456789abcdef

// Team tier
kota_team_team1234567890ab_0123456789abcdef0123456789abcdef

// Disabled (for testing disabled key handling)
kota_free_disabled12345678_0123456789abcdef0123456789abcdef
```

All test API keys use the same secret (`0123456789abcdef0123456789abcdef`) which is bcrypt-hashed in the database.

#### Test Repositories
- `testuser/test-repo` (user-owned)
- `solouser/solo-repo` (user-owned)
- `test-org/team-repo` (organization-owned)

### Schema

The test database uses the same schema as production:
- `auth.users` - Minimal auth schema for testing (mimics Supabase)
- `api_keys` - API key storage with bcrypt hashes
- `organizations` - Team workspaces
- `user_organizations` - Membership join table
- `repositories` - Git repositories
- `index_jobs` - Indexing job tracking
- `indexed_files` - Parsed source files
- `symbols`, `references`, `dependencies` - Code intelligence tables

## Writing Tests

### Using Test Helpers

Import test helpers from `tests/helpers/db.ts`:

```typescript
import { createAuthHeader, TEST_API_KEYS, TEST_USER_IDS } from "../helpers/db";

// Create auth header with test API key
const headers = {
  "Authorization": createAuthHeader("free"),  // or "solo", "team"
};

// Access test data IDs
const userId = TEST_USER_IDS.free;
const apiKey = TEST_API_KEYS.solo;
```

### Test Environment Variables

Tests automatically set these environment variables:

```typescript
process.env.SUPABASE_URL = "http://localhost:5434";
process.env.SUPABASE_SERVICE_KEY = "test-service-key-local";
process.env.SUPABASE_ANON_KEY = "test-anon-key-local";
process.env.DATABASE_URL = "postgresql://postgres:postgres@localhost:5434/postgres";
```

### Example Test

```typescript
import { describe, expect, test, beforeAll, afterAll } from "bun:test";
import { createAuthHeader } from "../helpers/db";

const TEST_PORT = 3100;
let server: ReturnType<typeof Bun.serve>;

beforeAll(async () => {
  // Set test environment
  process.env.SUPABASE_URL = "http://localhost:5434";
  process.env.SUPABASE_SERVICE_KEY = "test-service-key-local";
  process.env.SUPABASE_ANON_KEY = "test-anon-key-local";
  process.env.DATABASE_URL = "postgresql://postgres:postgres@localhost:5434/postgres";

  // Start test server with real database
  const { createRouter } = await import("@api/routes");
  const { getServiceClient } = await import("@db/client");

  const supabase = getServiceClient();
  const router = createRouter(supabase);

  server = Bun.serve({
    port: TEST_PORT,
    fetch: router.handle,
  });
});

afterAll(() => {
  server.stop();
});

describe("My Feature", () => {
  test("does something", async () => {
    const response = await fetch(`http://localhost:${TEST_PORT}/endpoint`, {
      headers: {
        "Authorization": createAuthHeader("free"),
      },
    });

    expect(response.status).toBe(200);
  });
});
```

## Available Package Scripts

KotaDB provides convenient npm/bun scripts for common test workflows:

| Script | Command | Description |
|--------|---------|-------------|
| `test:setup` | `./scripts/setup-test-db.sh` | First-time setup: start Supabase, generate .env.test, seed data |
| `test:teardown` | `supabase stop` | Stop all Supabase Local services |
| `test:reset` | `./scripts/reset-test-db.sh` | Reset database to clean state and re-seed |
| `test:env` | `./scripts/generate-env-test.sh` | Regenerate .env.test from Supabase status |
| `test:status` | `supabase status` | Show status of all Supabase services |

**Example workflow:**

```bash
# First time setup
bun run test:setup

# Run tests
bun test

# Need fresh data? Reset
bun run test:reset && bun test

# Done for the day
bun run test:teardown
```

## Troubleshooting

### Supabase CLI Not Installed

**Error:** `supabase: command not found`

**Solution:**
```bash
brew install supabase/tap/supabase  # macOS
# Or see: https://supabase.com/docs/guides/cli
```

### jq Not Installed

**Error:** `jq: command not found`

**Solution:**
```bash
brew install jq  # macOS
# Or: apt-get install jq (Linux)
```

### Docker Not Running

**Error:** `Cannot connect to the Docker daemon`

**Solution:**
- Start Docker Desktop (macOS/Windows)
- Or: `sudo systemctl start docker` (Linux)

### Port Already in Use

**Error:** `Port 5434 is already allocated`

**Solution:**
```bash
# Check what's using the port
lsof -ti:5434

# Stop conflicting Supabase instance
supabase stop

# Or kill the process
kill $(lsof -ti:5434)
```

### Tests Fail with "Connection Refused"

**Error:** `ECONNREFUSED localhost:5434`

**Solution:**
```bash
# Check if Supabase is running
bun run test:status

# If not running, start it
bun run test:setup
```

### .env.test Generation Failed

**Error:** `Failed to extract API keys from Supabase status`

**Solution:**
```bash
# Check Supabase status manually
supabase status --output json

# If services aren't running, restart
supabase stop && bun run test:setup
```

### Schema Mismatch Errors

**Error:** `relation "api_keys" does not exist`

**Solution:**
```bash
# Reset Supabase Local completely
supabase db reset

# Or stop and restart fresh
supabase stop
bun run test:setup
```

### Stale .env.test After Restart

If `.env.test` credentials don't match running services:

```bash
# Regenerate .env.test from current Supabase status
bun run test:env

# Verify credentials
cat .env.test
```

## CI/CD Integration

The test database runs in CI via GitHub Actions services. See `.github/workflows/ci.yml` for configuration.

Key steps:
1. Start PostgreSQL service container
2. Wait for health check
3. Run migrations and seed data
4. Execute test suite

## Antimocking Migration Complete

The KotaDB test suite now uses real PostgreSQL database connections instead of mocks.

**✅ Completed:**
- PostgreSQL test database container setup via Docker Compose
- Schema migrations for test environment (auth schema + main schema)
- Test data seeding scripts with deterministic test users, API keys, and repositories
- Real database test helper functions (`tests/helpers/db.ts`)
- All test files refactored to use real database:
  - MCP tests (`tests/mcp/*.test.ts`)
  - API tests (`tests/api/authenticated-routes.test.ts`)
  - Auth tests (`tests/auth/middleware.test.ts`, `tests/auth/validator.test.ts`)
- Mock helper files deleted (`tests/helpers/supabase-mock.ts`, `tests/helpers/auth-mock.ts`)
- CI/CD integration with PostgreSQL service container
- Setup and reset scripts for local development

**Benefits:**
- Tests exercise real database behavior (connections, timeouts, transactions)
- No mock maintenance burden
- True confidence in authentication and database flows
- Production parity testing

## Manual Database Inspection

To inspect the test database manually:

```bash
# Connect via psql
PGPASSWORD=postgres psql -h localhost -p 5434 -U postgres -d postgres

# Useful queries
SELECT * FROM api_keys;
SELECT * FROM indexed_files;
SELECT * FROM repositories;

# Check schema
\dt  -- List tables
\d api_keys  -- Describe api_keys table
```

## References

- [Anti-Mock Philosophy](../.claude/commands/anti-mock.md)
- [Supabase Setup Guide](./supabase-setup.md)
- [Database Schema](./schema.md)
- [Migration Guide (SQLite → Postgres)](./migration-sqlite-to-supabase.md)
